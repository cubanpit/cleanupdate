#!/bin/bash
#
# 'cleanupdate' by cubanpit at github.com
#
# Initial script found somewhere on internet (thanks to unknown).
# Menu taken from a script by Chrysostomus.
#
# This script should help you to maintain an ArchLinux-based system.
# Report issue at github.com/cubanpit/cleanupdate
#
################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# -e: Exit immediately if a command exits with a non-zero status.
# -u: Treat unset variables as an error when substituting.
set -eu

# Define some useful text style and color
_BOLD=$(/bin/tput bold)
_NORMAL=$(/bin/tput sgr0)
_RED=$(/bin/tput setaf 1)
_GREEN=$(/bin/tput setaf 2)
_YELLOW=$(/bin/tput setaf 3)
_AQUA=$(/bin/tput setaf 6)
readonly _BOLD _NORMAL _RED _GREEN _YELLOW _AQUA

# Default language is English, but Italian it's available
_LNG="eng"
if [[ "$LANG" =~ "it_IT" ]]; then
	_LNG="ita"
fi

# Check if $HOME is defined, otherwise many commands can't work
if [[ -z $HOME ]]; then
	if [[ $_LNG = ita ]]; then
		echo "ERRORE: la variabile d'ambiente $HOME è vuota,"\
			"è impossibile ottenere il percordo per la home dell'utente." 1>&2
	else
		echo "ERROR: $HOME variable not set properly,"\
			"it is impossible to get the path of user's home." 1>&2
	fi
	exit 1
fi

#
# Function to convert file size in a format easier to read, it receives file
#  size in bytes.
# Usage: human_size "size in bytes"
#
function human_size {
	_NUM=$1
	if [[ $_NUM -ge 1000000000 ]]; then
		_NUM="$(( _NUM / 1000000000 )) GB"
	elif [[ $_NUM -ge 1000000 ]]; then
		_NUM="$(( _NUM / 1000000 )) MB"
	elif [[ $_NUM -ge 1000 ]]; then
		_NUM="$(( _NUM / 1000 )) kB"
	elif [[ $_NUM -ge 0 ]]; then
		_NUM="$_NUM B"
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: impossibile convertire numeri negativi." 1>&2
		else
			echo "ERROR: it's not possible to convert negative numbers." 1>&2
		fi
		exit 1
	fi
	echo "$_NUM"
}

#
# Function to print a message after a transaction, communicating if it has been
#  executed, has been cenceled or has been skipped because unuseful.
# Usage: end_msg "ok|no|skip|warn" "message"
function end_msg {
	_MOD=$1
	_MSG=$2
	if [[ $_MOD = ok ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_GREEN}ESEGUITO${_NORMAL}"\
				"${_BOLD}] $_MSG ${_NORMAL}"
		else
			echo "${_BOLD}[${_GREEN}DONE${_NORMAL}${_BOLD}]"\
				"$_MSG ${_NORMAL}"
		fi
	elif [[ $_MOD = no ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_RED}ANNULLATO${_NORMAL}${_BOLD}]"\
				"$_MSG ${_NORMAL}"
		else
			echo "${_BOLD}[${_RED}CANCELED${_NORMAL}${_BOLD}]"\
				"$_MSG ${_NORMAL}"
		fi
	elif [[ $_MOD = skip ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_AQUA}SALTATO${_NORMAL}${_BOLD}]"\
				"$_MSG ${_NORMAL}"
		else
			echo "${_BOLD}[${_AQUA}SKIPPED${_NORMAL}${_BOLD}]"\
				"$_MSG ${_NORMAL}"
		fi
	elif [[ $_MOD = warn ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_YELLOW}ATTENZIONE${_NORMAL}"\
				"${_BOLD}] $_MSG ${_NORMAL}"
		else
			echo "${_BOLD}[${_YELLOW}WARNING${_NORMAL}"\
				"${_BOLD}] $_MSG ${_NORMAL}"
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: modalità sconosciuta, vedere funzione end_msg()." 1>&2
		else
			echo "ERROR: unknown option, see end_msg() function." 1>&2
		fi
		exit 1
	fi
}

#
# Function to print a question, setting the default answer.
# Usage: qst_msg "yes|no" "question"
#
function qst_msg {
	_MOD=$1
	_MSG=$2
	if [[ $_MOD = yes ]]; then
		if [[ $_LNG = ita ]]; then
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$_MSG [S/n]?${_NORMAL} "
		else
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$_MSG [Y/n]?${_NORMAL} "
		fi
	elif [[ $_MOD = no ]]; then
		if [[ $_LNG = ita ]]; then
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$_MSG [s/N]?${_NORMAL} "
		else
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$_MSG [y/N]?${_NORMAL} "
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: risposta predefinita sconosciuta, vedere funzione"\
				"qst_msg()." 1>&2
		else
			echo "ERROR: unknown default answer, see qst_msg() function." 1>&2
		fi
		exit 1
	fi
}

#
# Function to check if the user is root.
# This script should not be executed as root.
#
function check_root {
	if [[ "$(id -u)" = "0" ]]
	then
		echo "This script should not be executed as root." 1>&2
		echo "Please retry running it as user." 1>&2
		exit 126
	fi
}

#
# Function to check arguments passed to the script.
# This script doesn't accept any argument.
#
function check_args {
	if [[ $# -gt 0 ]] ; then
		if [[ $_LNG = ita ]]; then
			echo "Errore! Sono stati forniti i seguenti argomenti:" 1>&2
		else
			echo "Error! Some arguments have been provided:" 1>&2
		fi
		echo -en "\t" 1>&2 ; for i in "$@" ; do echo -n "$i" 1>&2 ; \
			echo -n " " 1>&2 ; done ; echo 1>&2 ; echo 1>&2
		if [[ $_LNG = ita ]]; then
			echo "Cleanupdate non ha bisogno di alcuni argomento." 1>&2
		else
			echo "Cleanupdate doesn't need any argument." 1>&2
		fi
		exit 1
	fi
}

#
# Function containing all system update operation.
# Database sync, package upgrade, AUR upgrade.
#
function sys_update {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Aggiornamento del sistema::${_NORMAL} "
	else
		echo " ${_BOLD}::System update::${_NORMAL} "
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri aggiornare i pacchetti ufficiali"
	else
		qst_msg "yes" "Do you want to upgrade official packages"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		_DISTRO=""
		_DISTRO=$( /bin/grep -i manjaro /etc/lsb-release )
		if [[ -n $_DISTRO &&\
			"$( /bin/stat /etc/pacman.d/mirrorlist | /bin/grep 'Modify' | \
			/bin/cut -d' ' -f2 )" != "$( /bin/date +%Y-%m-%d )" ]]; then
		/bin/sudo /bin/pacman-mirrors -f10
		/bin/sudo /bin/pacman -Syyu --color always
	else
		/bin/sudo /bin/pacman -Syu --color always
	fi
	if /bin/sudo /bin/pacman -Syu 2>&1 | /bin/grep -q "is newer than"; then
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Sono presenti pacchetti con versione più recente di quelli presenti nei repository, desideri abbassarli di versione"
	else
		qst_msg "yes" "There are packages with newer version than those in repository, do you want to downgrade them"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		/bin/sudo /bin/pacman -Syuu --color always
	fi
fi
if [[ $_LNG = ita ]]; then
	end_msg "ok" "Aggiornamento pacchetti ufficiali"
else
	end_msg "ok" "Official packages upgrade"
fi
else
	if [[ $_LNG = ita ]]; then
		end_msg "no" "Aggiornamento pacchetti ufficiali"
	else
		end_msg "no" "Official packages upgrade"
	fi
fi
echo
if [[ $_LNG = ita ]]; then
	qst_msg "yes" "Desideri aggiornare i pacchetti di AUR"
else
	qst_msg "yes" "Do you want to upgrade AUR packages"
fi
read -r _SURE
if [[ $_SURE != "n" && $_SURE != "N" ]]; then
	if [[ $_ORPHCHECK = false ]]; then
		# Look for orphan packages, they could be pkgs removed from repositories
		#  and moved to AUR, better not to upgrade them silently.
		declare -a _ORP=""
		if /bin/pacman -Qdtq >/dev/null ; then
			readarray -t _ORP < <( /bin/pacman -Qdtq )
		fi
		if [[ -n ${_ORP[0]} ]]; then
			if [[ $_LNG = ita ]]; then
				end_msg "warn" "Sono presenti pacchetti orfani, se non sono stati installati volontariamente ne è consigliata la rimozione."
			else
				end_msg "warn" "There are orphan packages, if you haven't installed them explicitly it's a good choice to remove them."
			fi
			# This strange conditional structure handle errors from the pacman
			#  command, for example when the user answer 'No' to a pacman
			#  question the script shouldn't crash.
			# This is far from elegant, because it handles also other errors
			#  like trivial ones.
			if /bin/sudo /bin/pacman --color always -Rs "${_ORP[@]}" ; then
				echo
			else
				echo
			fi
		fi
		_ORPHCHECK=true
	fi
	# Check if pacaur or yaourt are installed
	if [[ -x /bin/pacaur ]]; then
		/bin/pacaur -Syua --color always
		if [[ $_LNG = ita ]]; then
			end_msg "ok" "Aggiornamento AUR"
		else
			end_msg "ok" "AUR upgrade"
		fi
	elif [[ -x /bin/yaourt ]]; then
		/bin/yaourt -Sua --color
		if [[ $_LNG = ita ]]; then
			end_msg "ok" "Aggiornamento AUR"
		else
			end_msg "ok" "AUR upgrade"
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "Non risulta installato né 'yaourt' né 'pacaur', non è"\
				"possibile accedere agli aggiornamenti AUR tramite questo script."
		else
			echo "You don't have neither 'yaourt' nor 'pacaur' installed,"\
				"you can't access AUR updates through this script."
		fi
		if [[ $_LNG = ita ]]; then
			end_msg "skip" "Aggiornamento AUR"
		else
			end_msg "skip" "AUR upgrade"
		fi
	fi
else
	if [[ $_LNG = ita ]]; then
		end_msg "no" "Aggiornamento AUR"
	else
		end_msg "no" "AUR upgrade"
	fi
fi
}

#
# Function containing all package cleaning operation.
# Orphaned packages cleaning, cache cleaning, database optimization.
#
function clean_pkg {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Pulizia pacchetti::${_NORMAL} "
	else
		echo " ${_BOLD}::Packages cleaning::${_NORMAL} "
	fi
	if [[ $_ORPHCHECK = false ]]; then
	echo
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri cercare pacchetti orfani?"
		else
			qst_msg "yes" "Do you want search for orphaned packages"
		fi
		read -r _SURE
		if [[ $_SURE != "n" && $_SURE != "N" ]]; then
			declare -a _ORP=""
			if /bin/pacman -Qdtq >/dev/null; then
				readarray -t _ORP < <( /bin/pacman -Qdtq )
			fi
			if [[ -n ${_ORP[0]} ]]; then
				# This strange conditional structure handle errors from the pacman
				#  command, for example when the user answer 'No' to a pacman
				#  question the script shouldn't crash.
				# This is far from elegant, because it handles also other errors
				#  like trivial ones.
				if /bin/sudo /bin/pacman --color always -Rs "${_ORP[@]}" ; then
					echo
				else
					echo
				fi
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Pacchetti orfani"
				else
					end_msg "ok" "Orphaned packages"
				fi
			else
				if [[ $_LNG = ita ]]; then
					echo "Non è presente alcun pacchetto orfano."
				else
					echo "There isn't any orphaned package."
				fi
				if [[ $_LNG = ita ]]; then
					end_msg "skip" "Pacchetti orfani"
				else
					end_msg "skip" "Orphaned packages"
				fi
			fi
			_ORPHCHECK=true
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pacchetti orfani"
			else
				end_msg "no" "Orphaned packages"
			fi
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri pulire la cache dei pacchetti installati (conservando le ultime 2 versioni)"
	else
		qst_msg "yes" "Do you want to clean the cache of installed packages (keeping 2 versions)"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		/bin/sudo /bin/paccache -rk2 --nocolor
		if [[ $_LNG = ita ]]; then
			end_msg "ok" "Pulizia cache pacchetti installati"
		else
			end_msg "ok" "Installed packages cache cleaning"
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia cache pacchetti installati"
		else
			end_msg "no" "Installed packages cache cleaning"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri pulire completamente la cache dei pacchetti non installati"
	else
		qst_msg "yes" "Do you want to completely clean the cache of uninstalled packages"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		/bin/sudo /bin/paccache -ruk0 --nocolor
		if [[ $_LNG = ita ]]; then
			end_msg "ok" "Pulizia cache pacchetti non installati"
		else
			end_msg "ok" "Uninstalled packages cache cleaning"
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia cache pacchetti non installati"
		else
			end_msg "no" "Uninstalled packages cache cleaning"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri ottimizzare (deframmentare) il database di pacman"
	else
		qst_msg "yes" "Do you want to optimize (defragment) pacman database"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# This part of the script try to check if the disk containing
		#  pacman database is a solid state drive.
		_ROTAT=false
		if [[ -d "/var/lib/pacman" ]]; then # check database existence
			# Find disk on which database is located
			_DISK=$(/bin/df -P /var/lib/pacman | /bin/tail -n 1 | \
				/bin/cut -d' ' -f 1 | /bin/sed -E 's/(\/dev\/|[0-9])//g')
			# Discover if database disk exist as device and is rotational
			[[ -n $_DISK && -b "/dev/$_DISK" && \
				-e "/sys/block/$_DISK/queue/rotational" && \
				$(/bin/cat "/sys/block/$_DISK/queue/rotational") -eq 1 ]] \
				&& _ROTAT=true
		fi
		if [[ "$_ROTAT" = true ]]; then
			/bin/sudo /bin/pacman-optimize --nocolor
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Ottimizzazione database"
			else
				end_msg "ok" "Database optimization"
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Il database di pacman non risiede su un"\
					"disco rotazionale, non è necessario eseguire la deframmentazione."
			else
				echo "The pacman database lives on a non"\
					"rotational disk, defragmentation is not needed."
			fi
			if [[ $_LNG = ita ]]; then
				end_msg "skip" "Ottimizzazione database"
			else
				end_msg "skip" "Database optimization"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Ottimizzazione database"
		else
			end_msg "no" "Database optimization"
		fi
	fi
	# Here we'll check for '.pacnew' files, then catch '.pacnew' files that are
	#  useless (there is 'foo.conf.pacnew' and not 'foo.conf'), finally warn the
	#  user about it.
	declare -i i=0
	declare -a _PACNEW=""
	while IFS= read -r -d '' file; do
		_PACNEW[i++]="$file"
	done < <(/bin/find /etc -name "*.pacnew" -print0 2>/dev/null)
	declare -a _ORPHPACNEW=""
	if [[ -n ${_PACNEW[0]} ]]; then
		unset i
		declare -i j=0
		for i in "${_PACNEW[@]}"; do
			_PACCONF=${i//\.pacnew/}
			if [[ ! -f "$_PACCONF" ]]; then
				_ORPHPACNEW[j++]="$_PACCONF.pacnew"
			fi
		done
	fi

	if [[ ${#_PACNEW[@]} -eq ${#_ORPHPACNEW[@]} || ${#_PACNEW[@]} -eq 0 ]]; then
		_PACNCTRL=false
	else
		_PACNCTRL=true
	fi
	if [[ -n ${_ORPHPACNEW[0]} ]]; then
		echo
		for i in "${_ORPHPACNEW[@]}"; do
			echo "$i"
		done
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Sono presenti questi ${#_ORPHPACNEW[@]} file '.pacnew' orfani (consultare la documentazione [8] per maggiori informazioni), vuoi eliminarli"
		else
			qst_msg "yes" "These are ${#_ORPHPACNEW[@]} orphan '.pacnew' files (read documentation [8] for further information), do you want to erase them"
		fi
		read -r _SURE
		if [[ $_SURE != "n" && $_SURE != "N" ]]; then
			for i in "${_ORPHPACNEW[@]}"; do
				/bin/sudo /bin/rm -f "$i"
			done
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "File di configurazione orfani"
			else
				end_msg "ok" "Orphan configuration files"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "File di configurazione orfani"
			else
				end_msg "no" "Orphan configuration files"
			fi
		fi
	fi
	if [[ $_PACNCTRL = true ]]; then
		echo
		if [[ $_LNG = ita ]]; then
			end_msg "warn" "Sono presenti nuove versioni di alcuni file di configurazione. Valutare le modifiche tramite il comando 'pacdiff'. Consultare la documentazione [8] per maggiori informazioni."
		else
			end_msg "warn" "There are updated version of some configuration files. Assess the changes with the command 'pacdiff'. Read documentation [8] for further information."
		fi
	fi
}

#
# Function containing all file cleaning operation.
# Cache & thumbs cleaning, residual file cleaning, trash cleaning.
#
function clean_file {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Pulizia file::${_NORMAL} "
	else
		echo " ${_BOLD}::Files cleaning::${_NORMAL} "
	fi
	if [[ "$(/bin/cat /proc/1/comm)" = systemd ]]; then
		echo
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri ripulire i file di log per guadagnare spazio su disco"
		else
			qst_msg "yes" "Do you want to clean log files to save disk space"
		fi
		read -r _SURE
		if [[ $_SURE != "n" && $_SURE != "N" ]]; then
			/bin/sudo /bin/journalctl --vacuum-size=200M --vacuum-time=2weeks | /bin/tail -n 1
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Pulizia file di log"
			else
				end_msg "ok" "Log files cleaning"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pulizia file di log"
			else
				end_msg "no" "Log files cleaning"
			fi
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri stimare lo spazio occupato dai file poco recenti nella cache e tra le miniature"
	else
		qst_msg "yes" "Do you want to estimate disk space taken by old cache and thumbnails"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# This part checks the existence of thumbnails and cache folders, then
		#  calculate the total space they take.
		_OLD=0
		if [[ -d "$HOME/.thumbnails" ]]; then
			_OLD=$(echo "$_OLD+$( /bin/find "$HOME/.thumbnails" -type f\
				-atime +30 -print0 | /bin/du --files0-from=- -cb |\
				/bin/tail -1 | /bin/cut -f 1 )" | bc)
			_OLD=$(echo "$_OLD+$( /bin/find "$HOME/.thumbnails" -empty -type d\
				-atime +30 -print0 | /bin/du --files0-from=- -cb |\
				/bin/tail -1 | /bin/cut -f 1 )" | bc)
		fi
		if [[ -d "$HOME/.thumbnails" ]]; then
			_OLD=$(echo "$_OLD+$( /bin/find "$HOME/.cache" -name pacaur\
				-prune -o \( -type f -atime +30 -print0 \) | /bin/du\
				--files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
			_OLD=$(echo "$_OLD+$( /bin/find "$HOME/.cache" -name pacaur\
				-prune -o \( -empty -type d -atime +30 -print0 \) | /bin/du\
				--files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
		fi
		if [[ $_OLD -gt 0 ]]; then
			_OLD=$(human_size "$_OLD")
			if [[ $_LNG = ita ]]; then
				qst_msg "yes" "L'eliminazione di questi file libererà $_OLD di spazio su disco, vuoi procedere"
			else
				qst_msg "yes" "The deletion of these files frees $_OLD of disk space, do you want to continue"
			fi
			read -r _SURE
			if [[ $_SURE != "n" && $_SURE != "N" ]]; then
				if [[ -d "$HOME/.thumbnails" ]]; then
					/bin/find "$HOME/.thumbnails" -type f -atime +30 -print0 |\
						xargs -0 /bin/rm -f
					/bin/find "$HOME/.thumbnails" -empty -type d -atime +30\
						-print0 | xargs -0 /bin/rm -rf
				fi
				if [[ -d "$HOME/.cache" ]]; then
					/bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
						\( -type f -atime +30 -print0 \) | xargs -0 /bin/rm -f
					/bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
						\( -empty -type d -atime +30 -print0 \) | xargs -0\
						/bin/rm -rf
				fi
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Pulizia cache e miniature"
				else
					end_msg "ok" "Thumbs and cache cleaning"
				fi
			else
				if [[ $_LNG = ita ]]; then
					end_msg "no" "Pulizia cache e miniature"
				else
					end_msg "no" "Thumbs and cache cleaning"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Non c'è necessità di eliminare alcun"\
					"file, le cartelle sono sufficientemente pulite."
			else
				echo "There is no need to delete any file,"\
					"these folders are pretty clean."
			fi
			if [[ $_LNG = ita ]]; then
				end_msg "skip" "Pulizia cache e miniature"
			else
				end_msg "skip" "Thumbs and cache cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia cache e miniature"
		else
			end_msg "no" "Thumbs and cache cleaning"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri cercare file residui"
	else
		qst_msg "yes" "Do you want to search for residual files"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# Null separated output will be used just to have less problem with
		#  strange characters.
		declare -i i=0
		declare -a _RES=""
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "*~" -user "$USER" -print0\
			2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name ".*.swp" -user "$USER" -print0\
			2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "Desktop.ini" -user "$USER"\
			-print0 2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "Thumbs.db" -user "$USER" -print0\
			2>/dev/null)
		if [[ -n ${_RES[0]} ]]; then
			# Print every residual file
			unset i
			for i in "${_RES[@]}"; do
				echo "$i"
			done
			# Calculate space taken by residual files
			_RESP=0
			for i in "${_RES[@]}"; do
				_RESP=$( echo "$_RESP+$( /bin/du -b "$i" | /bin/cut -f 1 )" | bc )
			done
			_RESP=$(human_size "$_RESP")
			if [[ $_LNG = ita ]]; then
				qst_msg "no" "Ci sono ${#_RES[@]} file residui che occupano $_RESP di spazio su disco, desideri rimuoverli"
			else
				qst_msg "no" "There are ${#_RES[@]} residual files that take $_RESP of disk space, do you want to remove them"
			fi
			read -r _SURE
			if [[ ( $_LNG != ita && ( $_SURE = y || $_SURE = Y )) || ( $_LNG = ita && ( $_SURE = s || $_SURE = S ) ) ]]; then
				# Remove every residual file
				for i in "${_RES[@]}"; do
					/bin/rm -f "$i"
				done
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Pulizia file residui"
				else
					end_msg "ok" "Residual files cleaning"
				fi
			else
				if [[ $_LNG = ita ]]; then
					end_msg "no" "Pulizia file residui"
				else
					end_msg "no" "Residual files cleaning"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Non sono presenti file residui."
			else
				echo "There are no residual files."
			fi
			if [[ $_LNG = ita ]]; then
				end_msg "skip" "Pulizia file residui"
			else
				end_msg "skip" "Residual files cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia file residui"
		else
			end_msg "no" "Residual files search"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri controllare lo stato del cestino"
	else
		qst_msg "yes" "Do you want to check trash status"
	fi
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		if [[ -d "$HOME/.local/share/Trash/files" ]]; then
			declare -i i=0
			declare -a _TRASH=""
			while IFS= read -r -d '' file; do
				_TRASH[i++]="$file"
			done < <(/bin/find "$HOME/.local/share/Trash/files" -mindepth 1 -maxdepth 1 -print0 2>/dev/null)
			# This for loop counts total space taken by files and prints every
			#  file name next to the file size.
			unset i
			_TRASP=0
			if [[ -n ${_TRASH[0]} ]]; then
				for i in "${_TRASH[@]}"; do
					_FILENAME=$( basename "$i" )
					_FILESIZE=$( /bin/du -bs "$i" | /bin/cut -f 1 )
					_TRASP=$( echo "$_TRASP+$_FILESIZE" | bc )
					_FILESIZE=$( human_size "$_FILESIZE" )
					echo -ne "   $_FILESIZE   \t"
					if [[ -d "$i" ]]; then
						_FILENAME+="/"
						echo "${_BOLD}$_FILENAME${_NORMAL}"
					else
						echo "$_FILENAME"
					fi
				done
				_TRASP=$(human_size "$_TRASP")
				if [[ $_LNG = ita ]]; then
					qst_msg "no" "Sono presenti ${#_TRASH[@]} elementi che occupano $_TRASP di spazio sul disco, desideri eliminarli definitivamente"
				else
					qst_msg "no" "There are ${#_TRASH[@]} items that take $_TRASP of disk space, do you want do definetely delete them"
				fi
				read -r _SURE
				if [[ ( $_LNG != ita && ( $_SURE = y || $_SURE = Y ) ) || ( $_LNG = ita && ( $_SURE = s || $_SURE = S ) ) ]]; then
					/bin/rm -rf "$HOME/.local/share/Trash/files"
					/bin/rm -rf "$HOME/.local/share/Trash/info"
					if [[ $_LNG = ita ]]; then
						end_msg "ok" "Pulizia cestino"
					else
						end_msg "ok" "Trash cleaning"
					fi
				else
					if [[ $_LNG = ita ]]; then
						end_msg "no" "Pulizia cestino"
					else
						end_msg "no" "Trash cleaning"
					fi
				fi
			else
				if [[ $_LNG = ita ]]; then
					echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
				else
					echo "Trash is completely empty, there is no need to clean it."
				fi
				if [[ $_LNG = ita ]]; then
					end_msg "skip" "Pulizia cestino"
				else
					end_msg "skip" "Trash cleaning"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
			else
				echo "Trash is completely empty, there is no need to clean it."
			fi
			if [[ $_LNG = ita ]]; then
				end_msg "skip" "Pulizia cestino"
			else
				end_msg "skip" "Trash cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia cestino"
		else
			end_msg "no" "Trash cleaning"
		fi
	fi
}

#
# Function containing pacman troubleshooting
#
function trouble_shoot {
	_AGAIN=true
while [[ $_AGAIN = true ]]; do
	clear
	if [[ $_LNG = ita ]]; then
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Indicare quale di questi"\
			"messaggi restituisce il gestore di pacchetti:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (file in conflitto)"
		echo "${_BOLD}[2] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (il pacchetto non è valido oppure è"\
			"corrotto (firma PGP))"
		echo "${_BOLD}[3] ->${_NORMAL} errore: impossibile scaricare il"\
			"pacchetto '...' da ..."
		echo "${_BOLD}[4] ->${_NORMAL} errore: impossibile bloccare il"\
			"database: File già esistente"
		echo -e "\nSe il problema non è qui elencato si consiglia di chiedere"\
			"aiuto sul forum online della propria distribuzione."
		echo "${_BOLD}[q|0] ->${_NORMAL} Torna al menù principale"
		echo -en "\n${_BOLD}Opzione: ${_NORMAL}"
		read -r -n1 _SURE
		case $_SURE in
			q|0) 	_AGAIN=false
				;;
			1)	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti si accorge che per installare un determinato"\
					"pacchetto sarebbe neccessario sovrascrivere un file già"\
					"presente nel sistema. Il nome del file in questione viene"\
					"stampato insieme al messaggio di errore."
				echo "Ci sono due possibili soluzioni:"
				echo "-> se vengono segnalati solo pochi file è possibile"\
					"rimuoverli manualmente tramite il comando 'sudo rm"\
					"/percorso/completo/file';"
				echo "-> se i file sono molto numerosi è possibile"\
					"automatizzare il processo dando al gestore di pacchetti"\
					"il permesso di sovrascrivere i file in conflitto, questa"\
					"opzione va utilizzata il meno possibile perché può avere"\
					"effetti collaterali anche gravi, per utilizzarla bisogna"\
					"lanciare il seguente comando di installazione fornendo il"\
					"nome del pacchetto che causa il problema 'sudo pacman -S"\
					"--force nomepacchetto'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			2) 	echo ; echo
				echo "Questo messaggio di errore segnala l'impossibilità di"\
					"verificare correttamente la provenienza di un pacchetto."
				echo "Generalmente può essere risolto lanciando il seguenti"\
					"comandi:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			3) 	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti non riesce a scaricare dai repository online"\
					"i database o i pacchetti richiesti."
				echo "La prima cosa da verificare è la corretta connessione"\
					"ad una rete internet del sistema in uso."
				echo "Se il sistema risulta connesso ad internet ma il"\
					"problema persiste è probabile che il gestore di pacchetti"\
					"si stia rivolgendo ad un server non funzionante oppure"\
					"obsoleto, è quindi necessario generare una nuova lista"\
					"dei mirror; sui sistemi Manjaro Linux è possibile farlo"\
					"tramite 'pacman-mirrors'."
				echo "Il comando consigliato per generare velocemente una"\
					"nuova lista dei mirror è 'sudo pacman-mirrors -f10'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			4) 	echo ; echo
				echo "Questo messaggio di errore segnala la presenza di un"\
					"file di lock, che indica un'operazione in corso da parte"\
					"del gestore di pacchetti, a volte questo file non viene"\
					"correttamente cancellato e rimane nonostante non ci sia"\
					"alcuna operazione in corso."
				echo "Dopo aver controllato che non ci sia alcun processo"\
					"di installazione/aggiornamento in atto (sia da parte di"\
					"pacman sia da parte dei gestori software da interfaccia"\
					"grafica) è possibile eliminare il file di lock lanciando"\
					"il comando 'sudo rm /var/lib/pacman/db.lck'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			*)	echo ; echo
				echo -n "Non esiste l'opzione '$_SURE'. Premi un tasto"\
					"qualsiasi per continuare. "
				read -rs -n1
		esac
	else
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Select the error"\
			"message printed by the package manager:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} error: failed to commit transaction"\
			"(conflicting files)"
		echo "${_BOLD}[2] ->${_NORMAL} error: failed to commit transaction"\
			"(invalid or corrupted package (PGP signature))"
		echo "${_BOLD}[3] ->${_NORMAL} error: failed retrieving file '...'"\
			"from ..."
		echo "${_BOLD}[4] ->${_NORMAL} error: failed to init transaction"\
			"(unable to lock database)"
		echo -e "\nIf the problem is not listed here ask to your"\
			"distribution's online forum for help."
		echo "${_BOLD}[q|0] ->${_NORMAL} Return to main menu"
		echo -en "\n${_BOLD}Option: ${_NORMAL}"
		read -r -n1 _SURE
		case $_SURE in
			q|0) 	_AGAIN=false
				;;
			1)	echo ; echo
				echo "This error message appears when the pckage manager needs"\
					"to overwrite an existing file in order to install a"\
					"certain package."\
					"The file name is printed in the error message."
				echo "There are two possible solutions:"
				echo "-> if there are only a few conflicting files, they can"\
					"be removed manually with 'sudo rm /path/to/file';"
				echo "-> if there are many conflicting files it is possible to"\
					"give pacman permission to overwrite them; however this"\
					"option can be dangerous and should be used only when"\
					"necessary; to use it read from the error message the name"\
					"of the package in question and execute 'sudo pacman -S"\
					"--force packagename'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			2) 	echo ; echo
				echo "This error message appears if pacman fails to verify the"\
					"source of a package."
				echo "These commands should solve the problem:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			3) 	echo ; echo
				echo "This error message appears if pacman fails to download"\
					"needed packages or database from online repository."
				echo "Verify first that your system is properly connected to a"\
					"network."
				echo "If the problem persists, it is possible that pacman is"\
					"trying to download files from a non working or obsolete"\
					"server, in this case the mirror list should be updated;"\
					"in a Manjaro Linux system you can use 'pacman-mirrors' to"\
					"accomplish that."
				echo "To generate a new mirrorlist in few seconds the"\
					"suggested command is 'sudo pacman-mirrors -f10'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			4) 	echo ; echo
				echo "This error message appears when pacman finds a lock"\
					"file, which indicates that a package management"\
					"transaction is in progress; however sometimes such files"\
					"remain also after the transaction is finished."
				echo "After making sure that no package management process"\
					"(from pacman or from any graphical package management"\
					"software) is in progress, then the lock file can be"\
					"removed launching 'sudo rm /var/lib/pacman/db.lck'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			*)	echo ; echo
				echo -n "There is no '$_SURE' option. Press any key to"\
					"continue. "
				read -rs -n1
		esac
	fi
done
}

#
# Function containing english documentation text.
#
function doc_eng {
less -R << EOF
Press 'q' to quit documentation

${_BOLD}${_YELLOW}::Update system::${_NORMAL}

${_BOLD}Update packages from repositories (pacman -Syu)${_NORMAL}
Checks that local database is up to date with online repositories, compare packages version between database and installed packages, if versions are different runs update.
It prints a warning if some packages are newer than those in repositories, it's possible to downgrade these packages with 'pacman -Syuu'.

${_BOLD}Update packages from AUR (yaourt -Sua)${_NORMAL}
Updates packages from AUR repository, if needed. It can use different tools for that: 'pacaur' or 'yaourt'.

${_BOLD}${_YELLOW}::Packages cleaning::${_NORMAL}

${_BOLD}Search and uninstall orphaned packages (pacman -Qdtq)${_NORMAL}
Searches for packages installed as dependencies and no longer required, if there are any it asks before uninstalling them.

${_BOLD}Clean the cache of installed packages (paccache -rk2)${_NORMAL}
By default pacman keeps forever a backup of every version of every installed package, this backups can grow and fill the hard disk, so it must be cleaned from time to time. This command removes all backups for all installed packages keeping only two version, just in case it is necessary to perform a downgrade.

${_BOLD}Clean the cache of uninstalled packages (paccache -ruk0)${_NORMAL}
See previous command explanation. This works with unisnstalled packages and doesn't keep any backup version.

${_BOLD}Optimize (defragment) pacman database (pacman-optimize)${_NORMAL}
This command simply optimize access to pacman database, defragmenting it. For SSD it doesn't change anything in performances and it does a lot of writes, so it's not recommended.

${_BOLD}Configuration files check${_NORMAL}
Searches '*.pacnew' files in '/etc' directory, these are files created by 'pacman' when a package changes its configuration file, this way it doesn't overwrite valuable user's configurations; 'pacnew' files are useless (orphan) without the 'non pacnew' file (same filename without '.pacnew'), but sometimes they remain after package removal. If there is any useful '.pacnew' file you should consult the difference with the command 'pacdiff', further information in 'pacdiff --help' or at https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave.

${_BOLD}${_YELLOW}::Files cleaning::${_NORMAL}

${_BOLD}Log files cleaning${_NORMAL}
Cleans log file if the total size is over 200MB or the age is over 1 week, using the command 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. It runs only on systems with systemd as init.
Log files contain informations about most important events that happens in an operating system while it is alive, they are useful to find out the cause of errors or malfunctions.

${_BOLD}Clean old cache and thumbnail files${_NORMAL}
Searches in '$HOME/.cache' and '$HOME/.thumbnails' for files with last access more than 30 days ago and delete them, delete also empty folders inside those directories. Cache and thumbnail files are not necessary and are used by user applications to load faster images thumbnails or information.

${_BOLD}Search and clean residual files${_NORMAL}
Searches for files with names matching 'Thumbs.db', 'Desktop.ini', '.*.swp' and '*~'. This files are temporary files from Windows (first and second one) and from Linux (last two) application, that store them to save some information during work; they're important when you're using some applications, but they should disappears few seconds later, sometimes they don't. You should save your document in every application in use before using this option.

${_BOLD}Clean trash files (rm -rfv $HOME/.local/share/Trash/*)${_NORMAL}
Simply cleans the user trash, files are located in '$HOME/.local/share/Trash/files'; prints all file names so the user at first glance can check deleted files and their number.

Press 'q' to quit documentation
EOF
}

#
# Function containing italian documentation text.
#
function doc_ita {
less -R << EOF
Premere 'q' per uscire dalla documentazione

${_BOLD}${_YELLOW}::Aggiornamento del sistema::${_NORMAL}

${_BOLD}Aggiornamento dei pacchetti dai repository ufficiali (pacman -Syu)${_NORMAL}
Controlla che il database locale sia aggiornato, se ci sono differenze tra le versioni dei pacchetti installati e di quelli presenti nel database effettua l'upgrade (innalzamento di versione). Il comando notifica se la versione installata di un pacchetto è più recente di quella nei repository, in questo caso può essere utile eseguire un downgrade (abbassamento di versione) tramite il comando 'pacman -Syuu'.

${_BOLD}Aggiornamento dei pacchetti di AUR (pacaur -Sua else
yaourt -Sua)${_NORMAL}
Effettua l'aggiornamento dei pacchetti provenienti dai repository AUR, se necessario. Può utilizzare come strumenti (in ordine di priorità) 'pacaur' oppure 'yaourt'.

${_BOLD}${_YELLOW}::Pulizia pacchetti::${_NORMAL}

${_BOLD}Ricerca e rimozione dei pacchetti orfani (pacman -Qdtq)${_NORMAL}
Effettua una ricerca dei pacchetti orfani, cioè quelli installati come dipendenza di un altro pacchetto attualmente non più installato sul sistema, o le cui dipendenze sono state modificate.

${_BOLD}Pulizia della cache dei pacchetti installati (paccache -rk2)${_NORMAL}
Elimina le vecchie versioni dei pacchetti installati che pacman tiene come backup, lasciando le ultime due versioni. Il gestore di pacchetti pacman come comportamento predefinito tiene tutte le vecchie versioni dei pacchetti installati (e non), questo utilissimo backup può occupare col tempo molta memoria. È quindi consigliabile ripulire saltuariamente la cache dei pacchetti, lasciando solo le ultime versioni dei pacchetti, che possono risultare utili in caso di necessità di downgrade (installazione della versione precedente di un pacchetto).

${_BOLD}Pulizia della cache dei pacchetti non installati (paccache -ruk0)${_NORMAL}
Come la voce precedente, ma per i pacchetti non più installati sul sistema. Non essendoci necessità di effettuare downgrade non conserva neanche una versione di backup.

${_BOLD}Ottimizzazione (deframmentazione) del database di pacman (pacman-optimize)${_NORMAL}
Ottimizza l'accesso al database di pacman, deframmentandolo. Non è un'ottimizzazione utile nel caso in cui si utilizzi un SSD a causa del funzionamento stesso dei dischi a stato solido, inoltre causa inutili scritture sul disco che nel caso degli SSD sarebbe meglio limitare se non necessarie.

${_BOLD}Verifica file di configurazione${_NORMAL}
Viene verificata la presenza di file '*.pacnew' nella cartella di sistema '/etc', questi file vengono creati da 'pacman' quando un pacchetto aggiorna il proprio file di configurazione, questo per evitare di sovrascrivere i preziosi file di configurazione modificati dall'utente; nel caso in cui il file 'pacnew' non abbia un corrispondente file di configurazione (ha lo stesso nome ma senza '.pacnew') allora viene considerato orfano e non ha nessuna utilità. Nel caso in cui siano presenti file 'pacnew' non orfani è consigliata la consultazione degli stessi tramite il comando 'pacdiff', maggiori informazioni tramite 'pacdiff --help' o nella pagina https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave_(Italiano).

${_BOLD}${_YELLOW}::Pulizia file::${_NORMAL}

${_BOLD}Pulizia file di log${_NORMAL}
Pulisce i file di log se la loro dimensione supera i 200MB o se sono più vecchi di 1 settimana tramite il comando 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. Esegue questa operazione solo se il systema di init è 'systemd'.
I file di log contengono un resoconto di tutti gli avvenimenti rilevanti che succedono durante il funzionamento del sistema operativo, sono molto utili per capire le cause di errori o malfunzionamenti.

${_BOLD}Pulizia cache e miniature non recenti${_NORMAL}
Ricerca nelle cartelle '$HOME/.cache' e '$HOME/.thumbnails' file con l'ultimo accesso risalente a più di 30 giorni prima e li cancella, elimina anche le eventuali cartelle vuote che si trovano all'interno. I file presenti in cache sono utilizzati dalle applicazioni per velocizzare alcune operazioni comuni (es. caricamento copertine album in un riproduttore multimediale), invece i thumbnails sono le miniature delle immagini che vengono utilizzate (es. dal gestore file) per caricare più velocemente le anteprime delle immagini presenti nel sistema.

${_BOLD}Ricerca e rimozione file residui${_NORMAL}
Effettua una ricerca sui file che si chiamano 'Thumbs.db', 'Desktop.ini', '.*.swp' e '*~'. I primi due sono file creati dai sistemi Windows ed inutili su di un sistema Linux, che possono comparire se si condividono alcune cartelle con il sistema operativo di casa Microsoft. Gli ultimi due tipi di file sono file temporanei creati da molte applicazioni come salvataggio temporaneo del lavoro in corso, utile nel caso in cui improvvisamente il sistema si spenga per esempio; può succedere che questi file rimangano nel sistema più a lungo del necessario, creando disordine ed occupando spazio. Si consiglia di salvare i propri documenti in tutte le applicazioni aperte prima di eseguire questa opzione.

${_BOLD}Pulizia cestino (rm -rf $HOME/.local/share/Trash/*)${_NORMAL}
Cancella tutti i file presenti nel cestino dell'utente, i cui file sono contenuti in '$HOME/.local/share/Trash/files', stampando tutti il nome dei file di modo che l'utente possa verificare velocemente l'entità dell'operazione.

Premere 'q' per uscire dalla documentazione
EOF
}

#
# This function prints the menu and handles choice of different options.
#
function main {
	while true; do
		clear
		unset _SURE

		# This variable is used to perform only one time 'per cycle' the check
		#  for orphan packages, otherwise the check will occur before AUR update
		#  and inside 'Clean packages' function.
		_ORPHCHECK=false

		echo
		echo "      _                                  _       _        "
		echo "  ___| | ___  __ _ _ __  _   _ _ __   __| | __ _| |_ ___  "
		echo " / __| |/ _ \/ _\` | '_ \| | | | '_ \ / _\` |/ _\` | __/ _ \ "
		echo "| (__| |  __/ (_| | | | | |_| | |_) | (_| | (_| | ||  __/ "
		echo " \___|_|\___|\__,_|_| |_|\__,_| .__/ \__,_|\__,_|\__\___| "
		echo "                              |_|                         "
		echo
		if [[ $_LNG = ita ]]; then
			echo " ┌────────────────────────────────────────┐"
			echo " │    1.  Aggiorna e pulisci tutto        │"
			echo " │    2.  Aggiorna il sistema             │"
			echo " │    3.  Pulisci i pacchetti             │"
			echo " │    4.  Pulisci i file                  │"
			echo " │                                        │"
			echo " │    7.  Risoluzione problemi frequenti  │"
			echo " │    8.  Documentazione                  │"
			echo " │    9.  Cambia lingua (eng|${_BOLD}ita${_NORMAL})         │"
			echo " │  q|0.  ESCI                            │"
			echo " └────────────────────────────────────────┘"
			echo
			echo -n " Seleziona un'opzione : "
		else
			echo " ┌────────────────────────────────────────┐"
			echo " │    1.  Update and clean everything     │"
			echo " │    2.  Update system                   │"
			echo " │    3.  Clean packages                  │"
			echo " │    4.  Clean files                     │"
			echo " │                                        │"
			echo " │    7.  Solve commmon errors            │"
			echo " │    8.  Documentation                   │"
			echo " │    9.  Change language (${_BOLD}eng${_NORMAL}|ita)       │"
			echo " │  q|0.  QUIT                            │"
			echo " └────────────────────────────────────────┘"
			echo
			echo -n " Select an option : "
		fi
		read -rs -n1 _SURE
		case $_SURE in
			1)
				clear
				sys_update
				echo
				clean_pkg
				echo
				clean_file
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			2)
				clear
				sys_update
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			3)
				clear
				clean_pkg
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			4)
				clear
				clean_file
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			7)
				clear
				trouble_shoot
				;;
			8)
				clear
				if [[ $_LNG = ita ]]; then
					doc_ita
				else
					doc_eng
				fi
				;;
			9)
				if [[ $_LNG = ita ]]; then
					_LNG="eng"
				else
					_LNG="ita"
				fi
				;;
			q|0)
				# Clear terminal, scrollback included
				clear && echo -en "\e[3J"
				exit 0
				;;
			*)
				echo
				echo
				if [[ $_LNG = ita ]]; then
					echo -n " Non esiste l'opzione '$_SURE'. Premi un tasto"\
						"qualsiasi per continuare. "
				else
					echo -n " There is no '$_SURE' option. Press any key to"\
						"continue. "
				fi
				read -rs -n1
		esac
	done
}

# Here begins the "main script"

# Enable debug
#set -x

check_root
check_args "$@"

# Launch the long search for residual file and put everything in background,
#  this way the second execution will be faster on hard disk, because everything
#  is already in cache.
/bin/find "$HOME" -name "*Steam*" -prune -o -path "$HOME/.cache" -prune -o\
	-path "$HOME/.thumbnails" -prune -o -path "$HOME/.mozilla" -prune -o\
	-path "$HOME/.thunderbird" -prune -o -path "*/.git" -prune -o\
	-print >/dev/null 2>&1 &

main

# Disable debug
#set +x

exit 1
