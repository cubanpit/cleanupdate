#!/bin/bash
#
# 'cleanupdate' by cubanpit at github.com
#
# Initial script found somewhere on internet (thanks to unknown).
# Menu taken from a script by Chrysostomus.
#
# This script should help you to maintain an ArchLinux-based system.
# Report issues at github.com/cubanpit/cleanupdate
#
################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# -e: Exit immediately if a command exits with a non-zero status.
# -u: Treat unset variables as an error when substituting.
# -o pipefail: Pipe redirection raise an error if any command raise one.
set -e -u -o pipefail

# Default language is English, but Italian it's available
_LNG="eng"
if [[ "$LANG" =~ "it_IT" ]]; then
  _LNG="ita"
fi

# This script should not be executed as root.
if [[ "$(id -u)" = "0" ]]
then
  echo "This script should not be executed as root." 1>&2
  echo "Please retry running it as user." 1>&2
  exit 126
fi

# Check if /bin/tput is installed, otherwise some commands can't work
if [[ ! -x /bin/tput ]]; then
  if [[ $_LNG = ita ]]; then
    echo "ERRORE: /bin/tput non è presente sul sistema, verificare che la"\
      "libreria 'ncurses' sia installata correttamente." 1>&2
  else
    echo "ERROR: /bin/tput is not present in the system, verify that"\
      "verify that 'ncurses' library is properly installed." 1>&2
  fi
  exit 1
fi

# Define some useful text style and color
_BOLD=$(/bin/tput bold)
_NORMAL=$(/bin/tput sgr0)
_RED=$(/bin/tput setaf 1)
_GREEN=$(/bin/tput setaf 2)
_YELLOW=$(/bin/tput setaf 3)
_AQUA=$(/bin/tput setaf 6)
readonly _BOLD _NORMAL _RED _GREEN _YELLOW _AQUA

# Check if $HOME is defined, otherwise many commands can't work
if [[ -z $HOME ]]; then
  if [[ $_LNG = ita ]]; then
    echo "ERRORE: la variabile d'ambiente $HOME è vuota,"\
      "è impossibile ottenere il percorso per la home dell'utente." 1>&2
  else
    echo "ERROR: $HOME variable not set properly,"\
      "it is impossible to get the path of user's home." 1>&2
  fi
  exit 1
fi

#
# Function that prints warning message and wait for user input when the script
#  terminates unexpectedly.
#
function exit_trap {
  echo 1>&2
  echo 1>&2
  if [[ $_LNG = ita ]]; then
    echo "Lo script è terminato in modo non previsto. È possibile"\
      "rileggere alcuni messaggi di errore nel file '/tmp/cleanupdate.log'"\
      "fino al prossimo riavvio." 1>&2
    echo "Premere un tasto qualsiasi per uscire." 1>&2
  else
    echo "Script terminated unexpectedly. It is possible to read some error"\
      "messages also in '/tmp/cleanupdate.log' until the next reboot."\
      1>&2
    echo "Press any key to exit." 1>&2
  fi
  read -rs -n1
}

# Define trap for any type of EXIT, calls the previous defined function
trap exit_trap EXIT

# Define little function to print errors in stderr and in a logfile
function print_errors {
  /bin/tee --append "$logfile" 1>&2
}

#
# Function to convert file size in a format easier to read, it receives file
#  size in bytes.
# Usage: human_size "size in bytes"
#
function human_size {
  local num=$1
  if [[ $num -ge 1000000000 ]]; then
    num="$(( num / 1000000000 )) GB"
  elif [[ $num -ge 1000000 ]]; then
    num="$(( num / 1000000 )) MB"
  elif [[ $num -ge 1000 ]]; then
    num="$(( num / 1000 )) kB"
  elif [[ $num -ge 0 ]]; then
    num="$num B"
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: impossibile convertire numeri negativi." | \
        print_errors
    else
      echo "ERROR: it's not possible to convert negative numbers." | \
        print_errors
    fi
    exit 1
  fi
  echo "$num"
}

#
# Function to print a message after a transaction, communicating if it has been
#  executed, has been cenceled or has been skipped because unuseful.
# Usage: end_msg "ok|no|skip|warn" "message"
function end_msg {
  local mod=$1
  local msg=$2
  if [[ $mod = ok ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_GREEN}ESEGUITO${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_GREEN}DONE${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = no ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_RED}ANNULLATO${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_RED}CANCELED${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = skip ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_AQUA}SALTATO${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_AQUA}SKIPPED${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = warn ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_YELLOW}ATTENZIONE${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_YELLOW}WARNING${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: modalità sconosciuta, vedere funzione end_msg()." | \
        print_errors
    else
      echo "ERROR: unknown option, see end_msg() function." | print_errors
    fi
    exit 1
  fi
}

#
# Function to print a question, setting the default answer.
# Usage: qst_msg "yes|no" "question"
#
function qst_msg {
  local mod=$1
  local msg=$2
  # Empty stdin buffer, this way the distract user can not answer to every
  # question just pressing enter N times when the script begins.
  local discard
  set +e
  read -r -t 0.1 -n 1000 discard
  set -e
  unset discard
  if [[ $mod = yes ]]; then
    if [[ $_LNG = ita ]]; then
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [S/n]?${_NORMAL} "
    else
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [Y/n]?${_NORMAL} "
    fi
  elif [[ $mod = no ]]; then
    if [[ $_LNG = ita ]]; then
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [s/N]?${_NORMAL} "
    else
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [y/N]?${_NORMAL} "
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: risposta predefinita sconosciuta, vedere funzione"\
        "qst_msg()." | print_errors
    else
      echo "ERROR: unknown default answer, see qst_msg() function." | \
        print_errors
    fi
    exit 1
  fi
}

#
# Function to check arguments passed to the script.
# This script doesn't accept any argument.
#
function check_args {
  if [[ $# -gt 0 ]] ; then
    if [[ $_LNG = ita ]]; then
      echo "Errore! Sono stati forniti i seguenti argomenti:" | \
        print_errors
    else
      echo "Error! Some arguments have been provided:" | print_errors
    fi
    echo -en "\\t" | print_errors ; for i in "$@" ; \
    do echo -n "$i" | print_errors ; echo -n " " | print_errors ; done ; \
    echo | print_errors ; echo | print_errors
    if [[ $_LNG = ita ]]; then
      echo "Cleanupdate non ha bisogno di alcun argomento. Per maggiori"\
        "leggere il manuale cleanupdate(7)." | print_errors
    else
      echo "Cleanupdate doesn't need any argument. For further"\
        "information read the manual page cleanupdate(7)."| print_errors
    fi
    exit 1
  fi
}

#
# This function checks if there is any orphan package and asks the user if he
#  wants to remove them.
#
function orph_pkgs {
  echo -e "\\nStart orph_pkgs()\\n" >> "$logfile"
  echo
  if [[ $_LNG = ita ]]; then
    echo "Ricerca pacchetti orfani in corso..."
  else
    echo "Looking for orphan packages..."
  fi
  local -a orphans=""
  if /bin/pacman -Qdtq >/dev/null ; then
    readarray -t orphans < <( /bin/pacman -Qdtq )
  fi
  if [[ -n ${orphans[0]} ]]; then
    if [[ $_LNG = ita ]]; then
      end_msg "warn" "Sono presenti pacchetti orfani, se non sono stati installati volontariamente ne è consigliata la rimozione."
    else
      end_msg "warn" "There are orphan packages, if you haven't installed them explicitly it's a good choice to remove them."
    fi
    for i in "${orphans[@]}"; do
      echo "$i"
    done | /bin/column -x
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Sono presenti ${#orphans[@]} pacchetti orfani, desideri rimuoverli"
    else
      qst_msg "yes" "There are ${#orphans[@]} orphaned packages, do you want to remove them"
    fi
    read -r sure
    if [[ $sure != "n" && $sure != "N" ]]; then
      /bin/pkexec /bin/pacman --color always --noconfirm -Rs \
        "${orphans[@]}" 2> >(print_errors)
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pacchetti orfani"
      else
        end_msg "ok" "Orphan packages"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pacchetti orfani"
      else
        end_msg "no" "Orphan packages"
      fi
    fi
    echo
  else
    if [[ $_LNG = ita ]]; then
      end_msg "skip" "Non sono presenti pacchetti orfani."
    else
      end_msg "skip" "There are no orphan packages."
    fi
    echo
  fi
}

#
# Function containing all system update operation.
# Database sync, package upgrade, AUR upgrade.
#
function sys_update {
  echo -e "\\nStart sys_update()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Aggiornamento del sistema::${_NORMAL} "
  else
    echo " ${_BOLD}::System update::${_NORMAL} "
  fi
  echo
  if [[ $_LNG = ita ]]; then
    qst_msg "yes" "Desideri aggiornare i pacchetti ufficiali"
  else
    qst_msg "yes" "Do you want to upgrade official packages"
  fi
  read -r sure
  if [[ $sure != "n" && $sure != "N" ]]; then
    if [[ -x /bin/pacman-mirrors && \
      $( /bin/stat /etc/pacman.d/mirrorlist | /bin/grep 'Modify' | \
      /bin/cut -d' ' -f2 ) != $( /bin/date +%Y-%m-%d ) ]]; then
      if [[ $_LNG = ita ]]; then
        qst_msg "yes" "La lista dei mirror non viene aggiornata da più di un giorno, desideri aggiornarla"
      else
        qst_msg "yes" "The mirror list is more than one day old, do you want to refresh it"
      fi
      read -r sure
      if [[ $sure != "n" && $sure != "N" ]]; then
        if ! /bin/pkexec /bin/pacman-mirrors --fasttrack 10 2> >(print_errors) ; then
          if [[ $_LNG = ita ]]; then
            end_msg "no" "Aggiornamento mirrorlist"
          else
            end_msg "no" "Mirrorlist refresh"
          fi
        fi
        /bin/pkexec /bin/pacman -Syy 2> >(print_errors)
      else
        /bin/pkexec /bin/pacman -Sy 2> >(print_errors)
      fi
    else
      /bin/pkexec /bin/pacman -Sy 2> >(print_errors)
    fi
    if [[ $_LNG = ita ]]; then
      echo "Ricerca aggiornamenti in corso..."
    else
      echo "Looking for updates..."
    fi
    if [[ -n $(/bin/pacman -Qu 2> /dev/null) ]]; then
      # This way any pacman error during update doesn't stop the script
      #  at least it doesn't check the updates as done.
      if /bin/pkexec /bin/pacman -Su --color always 2> >(print_errors); then
        # Temporary disable 'pipefail' option, otherwise this condition
        #  does not work, maybe there is a better solution. TODO
        set +o pipefail
        if /bin/pkexec /bin/pacman -Su 2>&1 | \
          /bin/grep -q "is newer than"; then
          wait
          echo
          if [[ $_LNG = ita ]]; then
            qst_msg "yes" "Sono presenti pacchetti con versione più recente di quelli presenti nei repository, desideri abbassarli di versione"
          else
            qst_msg "yes" "There are packages with newer version than those in repository, do you want to downgrade them"
          fi
          read -r sure
          if [[ $sure != "n" && $sure != "N" ]]; then
            /bin/pkexec /bin/pacman -Suu --color always --noconfirm \
              2> >(print_errors)
          fi
        fi
        set -o pipefail
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento pacchetti ufficiali"
        else
          end_msg "ok" "Official packages upgrade"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Aggiornamento pacchetti ufficiali"
        else
          end_msg "no" "Official packages upgrade"
        fi
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Non sono disponibili nuovi aggiornamenti."
        end_msg "skip" "Aggiornamento pacchetti ufficiali"
      else
        echo "There isn't any available update."
        end_msg "skip" "Official packages upgrade"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      end_msg "no" "Aggiornamento pacchetti ufficiali"
    else
      end_msg "no" "Official packages upgrade"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    qst_msg "yes" "Desideri aggiornare i pacchetti di AUR"
  else
    qst_msg "yes" "Do you want to upgrade AUR packages"
  fi
  read -r sure
  if [[ $sure != "n" && $sure != "N" ]]; then
    orph_pkgs
    # Check if yay, trizen, pacaur or yaourt are installed
    if [[ -x /bin/yay ]]; then
      if /bin/yay -Sua 2> >(print_errors) ; then
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento AUR"
        else
          end_msg "ok" "AUR upgrade"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Aggiornamento AUR"
        else
          end_msg "no" "AUR upgrade"
        fi
      fi
    elif [[ -x /bin/trizen ]]; then
      if /bin/trizen -Sua 2> >(print_errors) ; then
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento AUR"
        else
          end_msg "ok" "AUR upgrade"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Aggiornamento AUR"
        else
          end_msg "no" "AUR upgrade"
        fi
      fi
    elif [[ -x /bin/yaourt ]]; then
      if /bin/yaourt -Sua --color 2> >(print_errors) ; then
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento AUR"
        else
          end_msg "ok" "AUR upgrade"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Aggiornamento AUR"
        else
          end_msg "no" "AUR upgrade"
        fi
      fi
    elif [[ -x /bin/pacaur ]]; then
      if [[ $_LNG = ita ]]; then
        end_msg "warn" "'pacaur' non è più mantenuto, si consiglia di installare un altro gestore per AUR: https://wiki.archlinux.org/index.php/AUR_helpers"
      else
        end_msg "warn" "'pacaur' is no longer maintained, it is reccomended to install another AUR helper: https://wiki.archlinux.org/index.php/AUR_helpers"
      fi
      if /bin/pacaur -Sua --color always 2> >(print_errors) ; then
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento AUR"
        else
          end_msg "ok" "AUR upgrade"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Aggiornamento AUR"
        else
          end_msg "ok" "AUR upgrade"
        fi
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Non risulta installato 'yay', 'trizen', 'yaourt' né 'pacaur', non è"\
          "possibile accedere agli aggiornamenti AUR tramite questo"\
          "script."
        end_msg "skip" "Aggiornamento AUR"
      else
        echo "You don't have 'yay', 'trizen', 'yaourt' or 'pacaur' installed,"\
          "you can't access AUR updates through this script."
        end_msg "skip" "AUR upgrade"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      end_msg "no" "Aggiornamento AUR"
    else
      end_msg "no" "AUR upgrade"
    fi
  fi
}

#
# Function containing all package cleaning operation.
# Orphaned packages cleaning, cache cleaning, database optimization.
#
function clean_pkg {
  echo -e "\\nStart clean_pkg()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Pulizia pacchetti::${_NORMAL} "
  else
    echo " ${_BOLD}::Packages cleaning::${_NORMAL} "
  fi
  orph_pkgs

  if [[ $_LNG = ita ]]; then
    echo "Controllo cache dei pacchetti installati in corso..."
  else
    echo "Checking installed package cache..."
  fi
  if /bin/paccache -dk2 | /bin/grep -q "no candidate packages found for pruning"; then
    if [[ $_LNG = ita ]]; then
      echo "Pulizia cache non necessaria."
      end_msg "skip" "Pulizia cache pacchetti installati"
    else
      echo "Cache cleaning not required."
      end_msg "skip" "Installed packages cache cleaning"
    fi
  else
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Desideri pulire la cache dei pacchetti installati (conservando le ultime 2 versioni)"
    else
      qst_msg "yes" "Do you want to clean the cache of installed packages (keeping 2 versions)"
    fi
    read -r sure
    if [[ $sure != "n" && $sure != "N" ]]; then
      /bin/pkexec /bin/paccache -rk2 --nocolor 2> >(print_errors)
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia cache pacchetti installati"
      else
        end_msg "ok" "Installed packages cache cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia cache pacchetti installati"
      else
        end_msg "no" "Installed packages cache cleaning"
      fi
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Controllo cache dei pacchetti disinstallati in corso..."
  else
    echo "Checking uninstalled package cache..."
  fi
  if /bin/paccache -duk0 | /bin/grep -q "no candidate packages found for pruning"; then
    if [[ $_LNG = ita ]]; then
      echo "Pulizia cache non necessaria."
      end_msg "skip" "Pulizia cache pacchetti disinstallati"
    else
      echo "Cache cleaning not required."
      end_msg "skip" "Uninstalled packages cache cleaning"
    fi
  else
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Desideri pulire completamente la cache dei pacchetti disinstallati"
    else
      qst_msg "yes" "Do you want to completely clean the cache of uninstalled packages"
    fi
    read -r sure
    if [[ $sure != "n" && $sure != "N" ]]; then
      /bin/pkexec /bin/paccache -ruk0 --nocolor 2> >(print_errors)
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia cache pacchetti disinstallati"
      else
        end_msg "ok" "Uninstalled packages cache cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia cache pacchetti disinstallati"
      else
        end_msg "no" "Uninstalled packages cache cleaning"
      fi
    fi
  fi
  echo
  # Here we'll check for '.pacnew' files, then catch '.pacnew' files that are
  #  useless (there is 'foo.conf.pacnew' and not 'foo.conf'), finally warn the
  #  user about it.
  # Temporarely disable pipefail option, find often reports non critical errors.
  set +o pipefail
  local i=0
  local -a pacnews=""
  while IFS= read -r -d '' file; do
    pacnews[i++]="$file"
  done < <(/bin/find /etc -name "*.pacnew" -print0 2>>"$logfile")
  set -o pipefail
  local -a orphan_pacnews=""
  if [[ -n ${pacnews[0]} ]]; then
    local -i j=0
    for i in "${pacnews[@]}"; do
      local pacold=${i//\.pacnew/}
      if [[ ! -f "$pacold" ]]; then
        orphan_pacnews[j++]="$pacold.pacnew"
      fi
    done
  fi
  if [[ -n ${orphan_pacnews[0]} ]]; then
    echo
    for i in "${orphan_pacnews[@]}"; do
      echo "$i"
    done
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Sono presenti questi ${#orphan_pacnews[@]} file '.pacnew' orfani (consultare la documentazione [8] per maggiori informazioni), vuoi eliminarli"
    else
      qst_msg "yes" "These are ${#orphan_pacnews[@]} orphan '.pacnew' files (read documentation [8] for further information), do you want to erase them"
    fi
    read -r sure
    if [[ $sure != "n" && $sure != "N" ]]; then
      for i in "${orphan_pacnews[@]}"; do
        /bin/pkexec /bin/rm -f "$i" 2> >(print_errors)
      done
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "File di configurazione orfani"
      else
        end_msg "ok" "Orphan configuration files"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "File di configurazione orfani"
      else
        end_msg "no" "Orphan configuration files"
      fi
    fi
  fi
  if [[ -n ${pacnews[0]} && ( ${#pacnews[@]} -gt ${#orphan_pacnews[@]} || -z ${orphan_pacnews[0]} ) ]]; then
    echo
    if [[ $_LNG = ita ]]; then
      end_msg "warn" "Sono presenti nuove versioni di alcuni file di configurazione. Valutare le modifiche tramite il comando 'pacdiff'. Consultare la documentazione [8] per maggiori informazioni."
    else
      end_msg "warn" "There are updated version of some configuration files. Assess the changes with the command 'pacdiff'. Read documentation [8] for further information."
    fi
  fi
}

#
# Function containing all file cleaning operation.
# Cache & thumbs cleaning, residual file cleaning, trash cleaning.
#
function clean_file {
  echo -e "\\nStart clean_file()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Pulizia file::${_NORMAL} "
  else
    echo " ${_BOLD}::Files cleaning::${_NORMAL} "
  fi
  if [[ "$(/bin/cat /proc/1/comm)" = systemd ]]; then
    echo
    if [[ $_LNG = ita ]]; then
      echo "Controllo della dimensione dei journal log in corso..."
    else
      echo "Checking journal log disk usage..."
    fi
    local log_size
    # Check journal log files, consider realistic cases only order of MB and GB.
    log_size=$(/bin/journalctl --disk-usage | sed -e "s/[a-z]//g" | \
      sed -e "s/\\s\\+/ /g" | cut -d" " -f 2)
    if echo "$log_size" | grep -q G ; then
      log_size=1000
    else
      log_size=1
    fi
    log_size=$(echo "$log_size*$(/bin/journalctl --disk-usage | \
      sed -e "s/[A-Za-z ]//g" | sed -e "s/\\..*$//g")" | bc)

    if [[ $log_size -ge 200 ]]; then
      if [[ $_LNG = ita ]]; then
        qst_msg "yes" "Potrebbe essere utile restringere il journal log, vuoi procedere"
      else
        qst_msg "yes" "It may be useful to trim journal log, do you want to continue"
      fi
      read -r sure
      if [[ $sure != "n" && $sure != "N" ]]; then
        /bin/pkexec /bin/journalctl --vacuum-size=200M \
          --vacuum-time=2weeks | /bin/tail -n 1 2> >(print_errors)
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Pulizia journal log"
        else
          end_msg "ok" "Journal log trimming"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Pulizia file di log"
        else
          end_msg "no" "Log files cleaning"
        fi
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "I file di log non occupano eccessivo spazio su disco."
        end_msg "skip" "Pulizia file di log"
      else
        echo "Log files do not use significant disk space."
        end_msg "skip" "Log files cleaning"
      fi
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Controllo dei log obsoleti in corso..."
  else
    echo "Checking obsolete log files..."
  fi
  # Check classic log files, they are considered a thousand time heavier
  # because they are also obsolete if older than 90 days.
  # Temporarely disable pipefail option, find often reports non critical errors.
  set +o pipefail
  local i=0
  local -a obsoletelogs=""
  while IFS= read -r -d '' file; do
    obsoletelogs[i++]="$file"
  done < <(/bin/find /var/log -name journal -prune -o \( -type f -ctime +90 \
    -print0 \) 2>>"$logfile")
  set -o pipefail
  if [[ -n ${obsoletelogs[0]} ]]; then
    # Print every obsolete log file
    for i in "${obsoletelogs[@]}"; do
      echo "$i"
    done | /bin/column -x
    if [[ $_LNG = ita ]]; then
      qst_msg "no" "Ci sono ${#obsoletelogs[@]} file di log obsoleti, desideri rimuoverli"
    else
      qst_msg "no" "There are ${#obsoletelogs[@]} obsolete log files, do you want to remove them"
    fi
    read -r sure
    if [[ ( $_LNG != ita && ( $sure = y || $sure = Y )) || ( $_LNG = ita && ( $sure = s || $sure = S ) ) ]]; then
      # Remove every residual file
      for i in "${obsoletelogs[@]}"; do
        /bin/pkexec /bin/rm -f "$i" 2> >(print_errors)
      done
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia file di log obsoleti"
      else
        end_msg "ok" "Obsolete log files cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia file di log obsoleti"
      else
        end_msg "no" "Obsolete log files cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non sono presenti file di log obsoleti."
      end_msg "skip" "Pulizia file di log obsoleti"
    else
      echo "There are no obsolete log files."
      end_msg "skip" "Obsolete log files cleaning"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Stima dello spazio occupato da cache e miniature poco recenti in"\
      "corso..."
  else
    echo "Calculating disk space taken by old cache and thumbnails..."
  fi
  # This part checks the existence of thumbnails and cache folders, then
  #  calculate the total space they take.
  # Disable pipefail option, because 'find' often exits with errors,
  #  but these are not critical.
  set +o pipefail
  local oldsize=0
  if [[ -d "$HOME/.thumbnails" ]]; then
    oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.thumbnails" -type f\
      -atime +30 -print0 2>>"$logfile" | /bin/du --files0-from=- -cb |\
      /bin/tail -1 | /bin/cut -f 1 )" | bc)
    oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.thumbnails" -empty -type d\
      -atime +30 -print0 2>>"$logfile" | /bin/du --files0-from=- -cb |\
      /bin/tail -1 | /bin/cut -f 1 )" | bc)
  fi
  if [[ -d "$HOME/.cache" ]]; then
    oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.cache" -name pacaur\
      -prune -o \( -type f -atime +30 -print0 \) 2>>"$logfile" | /bin/du\
      --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
    oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.cache" -name pacaur\
      -prune -o \( -empty -type d -atime +30 -print0 \) 2>>"$logfile" | /bin/du\
      --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
  fi
  set -o pipefail
  if [[ $oldsize -gt 0 ]]; then
    oldsize=$(human_size "$oldsize")
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "L'eliminazione di questi file libererà $oldsize di spazio su disco, vuoi procedere"
    else
      qst_msg "yes" "The deletion of these files frees $oldsize of disk space, do you want to continue"
    fi
    read -r sure
    if [[ $sure != "n" && $sure != "N" ]]; then
      # Disable pipefail option because 'find' often report not critical errors
      set +o pipefail
      if [[ -d "$HOME/.thumbnails" ]]; then
        /bin/find "$HOME/.thumbnails" -type f -atime +30 -print0 2>/dev/null |\
          xargs -0 /bin/rm -f 2> >(print_errors)
        /bin/find "$HOME/.thumbnails" -empty -type d -atime +30\
          -print0 2>/dev/null | xargs -0 /bin/rm -rf 2> >(print_errors)
      fi
      if [[ -d "$HOME/.cache" ]]; then
        /bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
          \( -type f -atime +30 -print0 \) 2>/dev/null | xargs -0 /bin/rm -f \
          2> >(print_errors)
        /bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
          \( -empty -type d -atime +30 -print0 \) 2>/dev/null | xargs -0\
          /bin/rm -rf 2> >(print_errors)
      fi
      set -o pipefail
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia cache e miniature"
      else
        end_msg "ok" "Thumbs and cache cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia cache e miniature"
      else
        end_msg "no" "Thumbs and cache cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non c'è necessità di eliminare alcun"\
        "file, le cartelle sono sufficientemente pulite."
      end_msg "skip" "Pulizia cache e miniature"
    else
      echo "There is no need to delete any file,"\
        "these folders are pretty clean."
      end_msg "skip" "Thumbs and cache cleaning"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Ricerca di file residui in corso..."
  else
    echo "Searching residual file..."
  fi
  # Null separated output will be used just to have less problem with
  #  strange characters.
  # Bash pipefail option is disabled temporarly, see previous comments.
  set +o pipefail
  local i=0
  local -a residfiles=""
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o \( -type f -atime +1 -name "*~"\
    -user "$USER" -print0 \) 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o \( -type f -atime +1 -name ".*.swp"\
    -user "$USER" -print0 \) 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o -name "Desktop.ini" -user "$USER"\
    -print0 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o -name "Thumbs.db" -user "$USER" -print0\
    2>>"$logfile")
  set -o pipefail
  if [[ -n ${residfiles[0]} ]]; then
    # Print every residual file
    for i in "${residfiles[@]}"; do
      echo "$i"
    done | /bin/column -x
    # Calculate space taken by residual files
    local residsize=0
    local filesize=0
    for i in "${residfiles[@]}"; do
      filesize=$( /bin/du -b "$i" | /bin/cut -f 1 )
      residsize=$( echo "$residsize+$filesize" | bc )
    done
    residsize=$(human_size "$residsize")
    if [[ $_LNG = ita ]]; then
      qst_msg "no" "Ci sono ${#residfiles[@]} file residui che occupano $residsize di spazio su disco, desideri rimuoverli"
    else
      qst_msg "no" "There are ${#residfiles[@]} residual files that take $residsize of disk space, do you want to remove them"
    fi
    read -r sure
    if [[ ( $_LNG != ita && ( $sure = y || $sure = Y )) || ( $_LNG = ita && ( $sure = s || $sure = S ) ) ]]; then
      # Remove every residual file
      for i in "${residfiles[@]}"; do
        /bin/rm -f "$i" 2> >(print_errors)
      done
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia file residui"
      else
        end_msg "ok" "Residual files cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia file residui"
      else
        end_msg "no" "Residual files cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non sono presenti file residui."
      end_msg "skip" "Pulizia file residui"
    else
      echo "There are no residual files."
      end_msg "skip" "Residual files cleaning"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Stima dimensioni dei file nel cestino in corso..."
  else
    echo "Checking trash files size..."
  fi
  if [[ -d "$HOME/.local/share/Trash/files" ]]; then
    # Bash pipefail option is disabled temporarly, see previous comments.
    set +o pipefail
    local i=0
    local -a trashfiles=""
    while IFS= read -r -d '' file; do
      trashfiles[i++]="$file"
    done < <(/bin/find "$HOME/.local/share/Trash/files" -mindepth 1\
      -maxdepth 1 -print0 2>>"$logfile")
    set -o pipefail
    local trashsize=0
    if [[ -n ${trashfiles[0]} ]]; then
      local filename=""
      local filesize=0
      # This for loop counts total space taken by files and prints every
      #  file name next to the file size.
      for i in "${trashfiles[@]}"; do
        filename=$( basename "$i" )
        filesize=$( /bin/du -bs "$i" | /bin/cut -f 1 )
        trashsize=$( echo "$trashsize+$filesize" | bc )
        filesize=$( human_size "$filesize" )
        echo -ne "   $filesize   \\t"
        if [[ -d "$i" ]]; then
          filename+="/"
          echo "${_BOLD}$filename${_NORMAL}"
        else
          echo "$filename"
        fi
      done
      trashsize=$(human_size "$trashsize")
      if [[ $_LNG = ita ]]; then
        qst_msg "no" "Sono presenti ${#trashfiles[@]} elementi che occupano $trashsize di spazio sul disco, desideri eliminarli definitivamente"
      else
        qst_msg "no" "There are ${#trashfiles[@]} items that take $trashsize of disk space, do you want do definetely delete them"
      fi
      read -r sure
      if [[ ( $_LNG != ita && ( $sure = y || $sure = Y ) ) || ( $_LNG = ita && ( $sure = s || $sure = S ) ) ]]; then
        /bin/rm -rf "$HOME/.local/share/Trash/files" 2> >(print_errors)
        /bin/rm -rf "$HOME/.local/share/Trash/info" 2> >(print_errors)
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Pulizia cestino"
        else
          end_msg "ok" "Trash cleaning"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Pulizia cestino"
        else
          end_msg "no" "Trash cleaning"
        fi
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
        end_msg "skip" "Pulizia cestino"
      else
        echo "Trash is completely empty, there is no need to clean it."
        end_msg "skip" "Trash cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
      end_msg "skip" "Pulizia cestino"
    else
      echo "Trash is completely empty, there is no need to clean it."
      end_msg "skip" "Trash cleaning"
    fi
  fi
}

#
# Function containing pacman troubleshooting
#
function trouble_shoot {
  echo -e "\\nStart trouble_shoot()\\n" >> "$logfile"
  local again=true
  local twidth
  twidth=$(tput cols)
while [[ $again = true ]]; do
  clear
  if [[ $_LNG = ita ]]; then
    echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Indicare quale di"\
      "questi messaggi restituisce il gestore di pacchetti:\\n${_NORMAL}"\
      | fmt -w "$twidth"
    echo "${_BOLD}[1] ->${_NORMAL} errore: impossibile eseguire"\
      "l'operazione richiesta (file in conflitto)" | fmt -w "$twidth"
    echo "${_BOLD}[2] ->${_NORMAL} errore: impossibile eseguire"\
      "l'operazione richiesta (il pacchetto non è valido oppure è"\
      "corrotto (firma PGP))" | fmt -w "$twidth"
    echo "${_BOLD}[3] ->${_NORMAL} errore: impossibile scaricare il"\
      "pacchetto '...' da ..." | fmt -w "$twidth"
    echo "${_BOLD}[4] ->${_NORMAL} errore: impossibile bloccare il"\
      "database: File già esistente" | fmt -w "$twidth"
    echo -e "\\nSe il problema non è qui elencato si consiglia di chiedere"\
      "aiuto sul forum online della propria distribuzione."\
      | fmt -w "$twidth"
    echo "${_BOLD}[q|0] ->${_NORMAL} Torna al menù principale"
    echo -en "\\n${_BOLD}Opzione: ${_NORMAL}"
    read -r -n1 sure
    case $sure in
      q|0)   again=false
        ;;
      1)  echo ; echo
        echo "Questo messaggio di errore compare quando il gestore"\
          "di pacchetti si accorge che per installare un determinato"\
          "pacchetto sarebbe necessario sovrascrivere un file già"\
          "presente nel sistema. Il nome del file in questione viene"\
          "stampato insieme al messaggio di errore." | fmt -w "$twidth"
        echo "Ci sono due possibili soluzioni:" | fmt -w "$twidth"
        echo "-> se vengono segnalati solo pochi file è possibile"\
          "rimuoverli manualmente tramite il comando 'sudo rm"\
          "/percorso/completo/file';" | fmt -w "$twidth"
        echo "-> se i file sono molto numerosi è possibile"\
          "automatizzare il processo dando al gestore di pacchetti"\
          "il permesso di sovrascrivere i file in conflitto, questa"\
          "opzione va utilizzata il meno possibile perché può avere"\
          "effetti collaterali anche gravi, per utilizzarla bisogna"\
          "lanciare il seguente comando di installazione fornendo il"\
          "nome del pacchetto che causa il problema 'sudo pacman -S"\
          "--force nomepacchetto'." | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      2)   echo ; echo
        echo "Questo messaggio di errore segnala l'impossibilità di"\
          "verificare correttamente la provenienza di un pacchetto."\
          | fmt -w "$twidth"
        echo "Generalmente può essere risolto lanciando il seguenti"\
          "comandi:" | fmt -w "$twidth"
        echo "  sudo rm -r /etc/pacman.d/gnupg"
        echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
        echo "  sudo pacman-key --init"
        echo "  sudo pacman-key --populate arch manjaro"
        echo "  sudo pacman-key --refresh-keys"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      3)   echo ; echo
        echo "Questo messaggio di errore compare quando il gestore"\
          "di pacchetti non riesce a scaricare dai repository online"\
          "i database o i pacchetti richiesti." | fmt -w "$twidth"
        echo "La prima cosa da verificare è la corretta connessione"\
          "ad una rete internet del sistema in uso." | fmt -w "$twidth"
        echo "Se il sistema risulta connesso ad internet ma il"\
          "problema persiste è probabile che il gestore di pacchetti"\
          "si stia rivolgendo ad un server non funzionante oppure"\
          "obsoleto, è quindi necessario generare una nuova lista"\
          "dei mirror; sui sistemi Manjaro Linux è possibile farlo"\
          "tramite 'pacman-mirrors'." | fmt -w "$twidth"
        echo "Il comando consigliato per generare velocemente una"\
          "nuova lista dei mirror è 'sudo pacman-mirrors -f10'."\
          | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      4)   echo ; echo
        echo "Questo messaggio di errore segnala la presenza di un"\
          "file di lock, che indica un'operazione in corso da parte"\
          "del gestore di pacchetti, a volte questo file non viene"\
          "correttamente cancellato e rimane nonostante non ci sia"\
          "alcuna operazione in corso." | fmt -w "$twidth"
        echo "Dopo aver controllato che non ci sia alcun processo"\
          "di installazione/aggiornamento in atto (sia da parte di"\
          "pacman sia da parte dei gestori software da interfaccia"\
          "grafica) è possibile eliminare il file di lock lanciando"\
          "il comando 'sudo rm /var/lib/pacman/db.lck'."\
          | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      *)  echo ; echo
        echo -n "Non esiste l'opzione '$sure'. Premi un tasto"\
          "qualsiasi per continuare. " | fmt -w "$twidth"
        read -rs -n1
    esac
  else
    echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Select the error"\
      "message printed by the package manager:\\n${_NORMAL}"\
      | fmt -w "$twidth"
    echo "${_BOLD}[1] ->${_NORMAL} error: failed to commit transaction"\
      "(conflicting files)" | fmt -w "$twidth"
    echo "${_BOLD}[2] ->${_NORMAL} error: failed to commit transaction"\
      "(invalid or corrupted package (PGP signature))" | fmt -w "$twidth"
    echo "${_BOLD}[3] ->${_NORMAL} error: failed retrieving file '...'"\
      "from ..." | fmt -w "$twidth"
    echo "${_BOLD}[4] ->${_NORMAL} error: failed to init transaction"\
      "(unable to lock database)" | fmt -w "$twidth"
    echo -e "\\nIf the problem is not listed here ask to your"\
      "distribution's online forum for help." | fmt -w "$twidth"
    echo "${_BOLD}[q|0] ->${_NORMAL} Return to main menu"
    echo -en "\\n${_BOLD}Option: ${_NORMAL}"
    read -r -n1 sure
    case $sure in
      q|0)   again=false
        ;;
      1)  echo ; echo
        echo "This error message appears when the pckage manager needs"\
          "to overwrite an existing file in order to install a"\
          "certain package. The file name is printed in the error"\
          "message." | fmt -w "$twidth"
        echo "There are two possible solutions:"
        echo "-> if there are only a few conflicting files, they can"\
          "be removed manually with 'sudo rm /path/to/file';"\
          | fmt -w "$twidth"
        echo "-> if there are many conflicting files it is possible to"\
          "give pacman permission to overwrite them; however this"\
          "option can be dangerous and should be used only when"\
          "necessary; to use it read from the error message the name"\
          "of the package in question and execute 'sudo pacman -S"\
          "--force packagename'." | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      2)   echo ; echo
        echo "This error message appears if pacman fails to verify the"\
          "source of a package." | fmt -w "$twidth"
        echo "These commands should solve the problem:"
        echo "  sudo rm -r /etc/pacman.d/gnupg"
        echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
        echo "  sudo pacman-key --init"
        echo "  sudo pacman-key --populate arch manjaro"
        echo "  sudo pacman-key --refresh-keys"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      3)   echo ; echo
        echo "This error message appears if pacman fails to download"\
          "needed packages or database from online repository."\
          | fmt -w "$twidth"
        echo "Verify first that your system is properly connected to a"\
          "network." | fmt -w "$twidth"
        echo "If the problem persists, it is possible that pacman is"\
          "trying to download files from a non working or obsolete"\
          "server, in this case the mirror list should be updated;"\
          "in a Manjaro Linux system you can use 'pacman-mirrors' to"\
          "accomplish that." | fmt -w "$twidth"
        echo "To generate a new mirrorlist in few seconds the"\
          "suggested command is 'sudo pacman-mirrors -f10'."\
          | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      4)   echo ; echo
        echo "This error message appears when pacman finds a lock"\
          "file, which indicates that a package management"\
          "transaction is in progress; however sometimes such files"\
          "remain also after the transaction is finished."\
          | fmt -w "$twidth"
        echo "After making sure that no package management process"\
          "(from pacman or from any graphical package management"\
          "software) is in progress, then the lock file can be"\
          "removed launching 'sudo rm /var/lib/pacman/db.lck'."\
          | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      *)  echo ; echo
        echo -n "There is no '$sure' option. Press any key to"\
          "continue. " | fmt -w "$twidth"
        read -rs -n1
    esac
  fi
done
}

#
# This function prints the menu and handles choice of different options.
#
function main {
  local sure
  while true; do
    clear
    unset sure

    echo
    echo "                ┌─── ┐   ┐"
    echo "                │    │   │"
    echo "                └────└───┘"
    echo "             cleanupdate v0.8"
    if [[ $_LNG = ita ]]; then
      echo " ┌────────────────────────────────────────┐"
      echo " │    1.  Aggiorna e pulisci tutto        │"
      echo " │    2.  Aggiorna il sistema             │"
      echo " │    3.  Pulisci i pacchetti             │"
      echo " │    4.  Pulisci i file                  │"
      echo " │                                        │"
      echo " │    7.  Risoluzione problemi frequenti  │"
      echo " │    8.  Documentazione                  │"
      echo " │    9.  Cambia lingua (eng|${_BOLD}ita${_NORMAL})         │"
      echo " │  q|0.  ESCI                            │"
      echo " └────────────────────────────────────────┘"
      echo
      echo -n " Seleziona un'opzione : "
    else
      echo " ┌────────────────────────────────────────┐"
      echo " │    1.  Update and clean everything     │"
      echo " │    2.  Update system                   │"
      echo " │    3.  Clean packages                  │"
      echo " │    4.  Clean files                     │"
      echo " │                                        │"
      echo " │    7.  Solve commmon errors            │"
      echo " │    8.  Documentation                   │"
      echo " │    9.  Change language (${_BOLD}eng${_NORMAL}|ita)       │"
      echo " │  q|0.  QUIT                            │"
      echo " └────────────────────────────────────────┘"
      echo
      echo -n " Select an option : "
    fi
    read -rs -n1 sure
    case $sure in
      1)
        clear
        sys_update
        echo
        clean_pkg
        echo
        clean_file
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      2)
        clear
        sys_update
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      3)
        clear
        clean_pkg
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      4)
        clear
        clean_file
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      7)
        clear
        trouble_shoot
        ;;
      8)
        clear
        if [[ $_LNG = ita ]]; then
          if ! man -L it -E UTF-8 cleanupdate 2> >(print_errors); then
            echo "Controllare le impostazioni di lingua del"\
              "sistema." | print_errors
            echo -n "Premi un tasto qualsiasi per continuare."
            read -rs -n1
          fi
        else
          if ! man -L en -E UTF-8 cleanupdate 2> >(print_errors); then
            echo "Check the system's locale setting." | print_errors
            echo -n "Press any key to continue. "
            read -rs -n1
          fi
        fi
        ;;
      9)
        if [[ $_LNG = ita ]]; then
          _LNG="eng"
        else
          _LNG="ita"
        fi
        ;;
      q|0)
        # Clear trap rules
        trap - EXIT
        # Clear terminal, scrollback included
        clear && echo -en "\\e[3J"
        exit 0
        ;;
      *)
        echo
        echo
        if [[ $_LNG = ita ]]; then
          echo -n " Non esiste l'opzione '$sure'. Premi un tasto"\
            "qualsiasi per continuare. "
        else
          echo -n " There is no '$sure' option. Press any key to"\
            "continue. "
        fi
        read -rs -n1
    esac
  done
}

# Here begins the "main script"

# Enable debug
#set -x

# Initialise logfile with current date and time.
logfile="/tmp/cleanupdate.log"
echo -e "\\n$(/bin/date -R) --- Cleanupdate errors log\\n" >> "$logfile"

check_args "$@"

# Launch the long search for residual file and put everything in background,
#  this way the second execution will be faster on hard disk, because everything
#  is already in cache.
if ! (/bin/find "$HOME" -name "*Steam*" -prune -o -path "$HOME/.cache" -prune -o\
  -path "$HOME/.thumbnails" -prune -o -path "$HOME/.mozilla" -prune -o\
  -path "$HOME/.thunderbird" -prune -o -path "*/.git" -prune -o\
  -print >/dev/null 2>>"$logfile" &) ; then
  echo "Errors running initial background 'find' job." >> "$logfile"
fi

main

# Disable debug
#set +x

exit 1
