#!/bin/bash
#
# 'cleanupdate' by cubanpit at github.com
#
# Initial script found somewhere on internet (thanks to unknown).
# Menu taken from a script by Chrysostomus.
#
# This script should help you to maintain an ArchLinux-based system.
# Report issues at github.com/cubanpit/cleanupdate
#
################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# -e: Exit immediately if a command exits with a non-zero status.
# -u: Treat unset variables as an error when substituting.
# -o pipefail: Pipe redirection raise an error if any command raise one.
set -e -u -o pipefail

# Default language is English, but Italian it's available
_LNG="eng"
if [[ "$LANG" =~ "it_IT" ]]; then
  _LNG="ita"
fi

# This script should not be executed as root.
if [[ "$(id -u)" = "0" ]]; then
  echo "This script should not be executed as root." 1>&2
  echo "Please retry running it as user." 1>&2
  exit 126
fi

# Check if tput is installed, otherwise some commands can't work
if [[ ! $(command -v tput) ]]; then
  if [[ $_LNG = ita ]]; then
    echo "ERRORE: tput non è presente sul sistema, verificare che la"\
      "libreria 'ncurses' sia installata correttamente." 1>&2
  else
    echo "ERROR: tput is not present in the system, verify that"\
      "verify that 'ncurses' library is properly installed." 1>&2
  fi
  exit 1
fi

# Define some useful text style and color
_BOLD=$(tput bold)
_NORMAL=$(tput sgr0)
_RED=$(tput setaf 1)
_GREEN=$(tput setaf 2)
_YELLOW=$(tput setaf 3)
_AQUA=$(tput setaf 6)
readonly _BOLD _NORMAL _RED _GREEN _YELLOW _AQUA

# Define TTY, in order to tell if we are on TTY or PTS
TTY=$(tty)
export TTY

# check if env variable is set in the right way
# https://stackoverflow.com/questions/3601515
if [ -z ${CU_PKEXEC+x} ]; then
  CU_PKEXEC="false"
fi

# Choose 'sudo' or 'pkexec' based on env variables
if [[ "$TTY" =~ tty || ! $(command -v pkexec) || $CU_PKEXEC != "true" ]]; then
  _SUDO="sudo"
else
  _SUDO="pkexec"
fi
readonly _SUDO

# Check if $HOME is defined, otherwise many commands can't work
if [[ -z $HOME ]]; then
  if [[ $_LNG = ita ]]; then
    echo "ERRORE: la variabile d'ambiente $HOME è vuota,"\
      "è impossibile ottenere il percorso per la home dell'utente." 1>&2
  else
    echo "ERROR: $HOME variable not set properly,"\
      "it is impossible to get the path of user's home." 1>&2
  fi
  exit 1
fi

#
# Function that prints warning message and wait for user input when the script
#  terminates unexpectedly.
#
function exit_trap {
  echo 1>&2
  echo 1>&2
  if [[ $_LNG = ita ]]; then
    echo "Lo script è terminato in modo non previsto. È possibile"\
      "rileggere alcuni messaggi di errore nel file '/tmp/cleanupdate.log'"\
      "fino al prossimo riavvio." 1>&2
    echo "Premere un tasto qualsiasi per uscire." 1>&2
  else
    echo "Script terminated unexpectedly. It is possible to read some error"\
      "messages also in '/tmp/cleanupdate.log' until the next reboot."\
      1>&2
    echo "Press any key to exit." 1>&2
  fi
  read -rs -n1
}

# Define trap for any type of EXIT, calls the previous defined function
trap exit_trap EXIT

# Define little function to print errors in stderr and in a logfile
function print_errors {
  tee --append "$logfile" 1>&2
}

#
# Function to convert file size in a format easier to read, it receives file
#  size in bytes.
# Usage: human_size "size in bytes"
#
function human_size {
  local num=$1
  if [[ $num -ge 1000000000 ]]; then
    num="$(( num / 1000000000 )) GB"
  elif [[ $num -ge 1000000 ]]; then
    num="$(( num / 1000000 )) MB"
  elif [[ $num -ge 1000 ]]; then
    num="$(( num / 1000 )) kB"
  elif [[ $num -ge 0 ]]; then
    num="$num B"
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: impossibile convertire numeri negativi." | \
        print_errors
    else
      echo "ERROR: it's not possible to convert negative numbers." | \
        print_errors
    fi
    exit 1
  fi
  echo "$num"
}

#
# Function to print a message after a transaction, communicating if it has been
#  executed, has been cenceled or has been skipped because unuseful.
# Usage: end_msg "ok|no|skip|warn" "message"
function end_msg {
  local mod=$1
  local msg=$2
  if [[ $mod = ok ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_GREEN}ESEGUITO${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_GREEN}DONE${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = no ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_RED}ANNULLATO${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_RED}CANCELED${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = skip ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_AQUA}SALTATO${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_AQUA}SKIPPED${_NORMAL}${_BOLD}]"\
        "$msg ${_NORMAL}"
    fi
  elif [[ $mod = warn ]]; then
    if [[ $_LNG = ita ]]; then
      echo "${_BOLD}[${_YELLOW}ATTENZIONE${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    else
      echo "${_BOLD}[${_YELLOW}WARNING${_NORMAL}"\
        "${_BOLD}] $msg ${_NORMAL}"
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: modalità sconosciuta, vedere funzione end_msg()." | \
        print_errors
    else
      echo "ERROR: unknown option, see end_msg() function." | print_errors
    fi
    exit 1
  fi
}

#
# Function to print a question, setting the default answer.
# Returns 0 for positive answer, 1 for negative answer.
# Usage: qst_msg "yes|no" "question" && answer=yes || answer=no
#
function qst_msg {
  local mod=$1
  local msg=$2
  # Empty stdin buffer, this way the distract user can not answer to every
  # question just pressing enter N times when the script begins.
  local discard
  set +e
  # shellcheck disable=SC2034
  read -r -t 0.1 -n 1000 discard
  set -e
  unset discard
  if [[ $mod = yes ]]; then
    if [[ $_LNG = ita ]]; then
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [S/n]?${_NORMAL} "
    else
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [Y/n]?${_NORMAL} "
    fi
    read -r sure
    if [[ $sure = n || $sure = N ]]; then
      return 1
    else
      return 0
    fi
  elif [[ $mod = no ]]; then
    if [[ $_LNG = ita ]]; then
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [s/N]?${_NORMAL} "
      read -r sure
      if [[ $sure = s || $sure = S ]]; then
        return 0
      else
        return 1
      fi
    else
      echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
        "$msg [y/N]?${_NORMAL} "
      read -r sure
      if [[ $sure = y || $sure = Y ]]; then
        return 0
      else
        return 1
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "ERRORE: risposta predefinita sconosciuta, vedere funzione"\
        "qst_msg()." | print_errors
    else
      echo "ERROR: unknown default answer, see qst_msg() function." | \
        print_errors
    fi
    exit 1
  fi
}

#
# Function to check arguments passed to the script.
# This script doesn't accept any argument.
#
function check_args {
  if [[ $# -gt 0 ]] ; then
    if [[ $_LNG = ita ]]; then
      echo "Errore! Sono stati forniti i seguenti argomenti:" | \
        print_errors
    else
      echo "Error! Some arguments have been provided:" | print_errors
    fi
    echo -en "\\t" | print_errors ; for i in "$@" ; \
    do echo -n "$i" | print_errors ; echo -n " " | print_errors ; done ; \
    echo | print_errors ; echo | print_errors
    if [[ $_LNG = ita ]]; then
      echo "Cleanupdate non ha bisogno di alcun argomento. Per maggiori"\
        "leggere il manuale cleanupdate(7)." | print_errors
    else
      echo "Cleanupdate doesn't need any argument. For further"\
        "information read the manual page cleanupdate(7)."| print_errors
    fi
    exit 1
  fi
}

#
# This function checks if there is any orphan package and asks the user if he
#  wants to remove them.
#
function orph_pkgs {
  echo -e "\\nStart orph_pkgs()\\n" >> "$logfile"
  echo
  function end_orph {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Pacchetti orfani"
    else
      end_msg "$1" "Orphan packages"
    fi
  }
  if [[ $_LNG = ita ]]; then
    echo "Ricerca pacchetti orfani in corso..."
  else
    echo "Looking for orphan packages..."
  fi
  local -a orphans=""
  if pacman -Qdtq >/dev/null ; then
    readarray -t orphans < <( pacman -Qdtq )
  fi
  if [[ -n ${orphans[0]} ]]; then
    if [[ $_LNG = ita ]]; then
      end_msg "warn" "Sono presenti pacchetti orfani, se non sono stati installati volontariamente ne è consigliata la rimozione."
    else
      end_msg "warn" "There are orphan packages, if you haven't installed them explicitly it's a good choice to remove them."
    fi
    for i in "${orphans[@]}"; do
      echo "$i"
    done | column -x
    if [[ $_LNG = ita ]]; then
      qst_msg "no" "Sono presenti ${#orphans[@]} pacchetti orfani, desideri rimuoverli" && sure=yes || sure=no
    else
      qst_msg "no" "There are ${#orphans[@]} orphaned packages, do you want to remove them" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      if $_SUDO pacman --color always --noconfirm -Rs \
          "${orphans[@]}" 2> >(print_errors); then
        end_orph "ok"
      else
        end_orph "no"
      fi
    else
      end_orph "no"
    fi
    echo
  else
    if [[ $_LNG = ita ]]; then
      echo "Non sono presenti pacchetti orfani."
      end_orph "skip"
    else
      echo "There are no orphan packages."
      end_orph "skip"
    fi
    echo
  fi
}

#
# Function containing all system update operation.
# Database sync, package upgrade, AUR upgrade.
#
function sys_update {
  echo -e "\\nStart sys_update()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Aggiornamento del sistema::${_NORMAL} "
  else
    echo " ${_BOLD}::System update::${_NORMAL} "
  fi
  echo
  function end_sysup {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Aggiornamento pacchetti ufficiali"
    else
      end_msg "$1" "Official packages upgrade"
    fi
  }
  if [[ $_LNG = ita ]]; then
    qst_msg "yes" "Desideri aggiornare i pacchetti ufficiali" && sure=yes || sure=no
  else
    qst_msg "yes" "Do you want to upgrade official packages" && sure=yes || sure=no
  fi
  if [[ $sure != no ]]; then
    # compute age of mirrorlist in days from last modification
    local ml_age=$(( ($(date +%s) - \
      $(stat --format %Y /etc/pacman.d/mirrorlist)) / 86400 ))
    if [[ $(command -v pacman-mirrors) && $ml_age -gt 0 ]]; then
      if [[ $_LNG = ita ]]; then
        qst_msg "yes" "La lista dei mirror non viene aggiornata da $ml_age giorno(i), desideri aggiornarla" && sure=yes || sure=no
      else
        qst_msg "yes" "The mirror list is $ml_age day(s) old, do you want to refresh it" && sure=yes || sure=no
      fi
      if [[ $sure != no ]]; then
        if ! $_SUDO pacman-mirrors --fasttrack 10 2> >(print_errors) ; then
          if [[ $_LNG = ita ]]; then
            end_msg "no" "Aggiornamento mirrorlist"
          else
            end_msg "no" "Mirrorlist refresh"
          fi
        fi
        if ! $_SUDO pacman -Syy 2> >(print_errors); then
          if [[ $_LNG = ita ]]; then
            end_msg "warn" "La lista dei mirror è stata aggiornata, si raccomanda un aggiornamento manuale dei database locali di pacman."
          else
            end_msg "warn" "Mirrorlist refreshed, it is reccomended to manual refresh pacman local databases."
          fi
          exit 1
        fi
      else
        if ! $_SUDO pacman -Sy 2> >(print_errors); then
          if [[ $_LNG = ita ]]; then
            end_msg "no" "Aggiornamento database locali"
          else
            end_msg "no" "Local database refresh"
          fi
        fi
      fi
    else
      if ! $_SUDO pacman -Sy 2> >(print_errors); then
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Aggiornamento database locali"
        else
          end_msg "no" "Local database refresh"
        fi
      fi
    fi
    if [[ $_LNG = ita ]]; then
      echo "Ricerca aggiornamenti in corso..."
    else
      echo "Looking for updates..."
    fi
    if [[ -n $(pacman -Qu 2> /dev/null) ]]; then
      # This way any pacman error during update doesn't stop the script
      if $_SUDO pacman -Su --color always 2> >(print_errors); then
        end_sysup "ok"
      else
        end_sysup "no"
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Non sono disponibili nuovi aggiornamenti."
        end_sysup "skip"
      else
        echo "There isn't any available update."
        end_sysup "skip"
      fi
    fi
  else
    end_sysup "no"
  fi
  echo
  function end_aurup {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Aggiornamento AUR"
    else
      end_msg "$1" "AUR upgrade"
    fi
  }
  if [[ $_LNG = ita ]]; then
    qst_msg "yes" "Desideri aggiornare i pacchetti di AUR" && sure=yes || sure=no
  else
    qst_msg "yes" "Do you want to upgrade AUR packages" && sure=yes || sure=no
  fi
  if [[ $sure != no ]]; then
    orph_pkgs
    # Check if yay, trizen or pamac are installed
    if [[ $(command -v yay) ]]; then
      if yay -Sua 2> >(print_errors) ; then
        end_aurup "ok"
      else
        end_aurup "no"
      fi
    elif [[ $(command -v trizen) ]]; then
      if trizen -Sua 2> >(print_errors) ; then
        end_aurup "ok"
      else
        end_aurup "no"
      fi
    elif [[ $(command -v pamac) ]]; then
      if [[ $_LNG = ita ]]; then
        echo "Verrà utilizzato Pamac per eseguire l'aggiornamento dei"\
          "pacchetti di AUR, date le caratteristiche di questo strumento"\
          "verrà anche avviato l'aggiornamento dei pacchetti ufficiali."
      else
        echo "Pamac is used to upgrade AUR packages, because of the"\
          "tool's characteristics an upgrade of official packages will"\
          "also be triggered."
      fi
      if pamac update --aur 2> >(print_errors) ; then
        end_aurup "ok"
      else
        end_aurup "no"
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Non risulta installato 'yay', 'trizen' né 'pamac', non è"\
          "possibile accedere agli aggiornamenti AUR tramite questo"\
          "script."
        end_aurup "skip"
      else
        echo "You don't have 'yay', 'trizen' or 'pamac' installed,"\
          "you can't access AUR updates through this script."
        end_aurup "skip"
      fi
    fi
  else
    end_aurup "no"
  fi
}

#
# Function containing all package cleaning operation.
# Orphaned packages cleaning, cache cleaning, database optimization.
#
function clean_pkg {
  echo -e "\\nStart clean_pkg()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Pulizia pacchetti::${_NORMAL} "
  else
    echo " ${_BOLD}::Packages cleaning::${_NORMAL} "
  fi
  orph_pkgs

  if [[ $_LNG = ita ]]; then
    echo "Controllo cache dei pacchetti installati in corso..."
  else
    echo "Checking installed package cache..."
  fi
  function end_pacc {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Pulizia cache pacchetti installati"
    else
      end_msg "$1" "Installed packages cache cleaning"
    fi
  }
  if paccache -dk2 | grep -q "no candidate packages found for pruning"; then
    if [[ $_LNG = ita ]]; then
      echo "Pulizia cache non necessaria."
      end_pacc "skip"
    else
      echo "Cache cleaning not required."
      end_pacc "skip"
    fi
  else
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Desideri pulire la cache dei pacchetti installati (conservando le ultime 2 versioni)" && sure=yes || sure=no
    else
      qst_msg "yes" "Do you want to clean the cache of installed packages (keeping 2 versions)" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      if $_SUDO paccache -rk2 --nocolor 2> >(print_errors); then
        end_pacc "ok"
      else
        end_pacc "no"
      fi
    else
      end_pacc "no"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Controllo cache dei pacchetti disinstallati in corso..."
  else
    echo "Checking uninstalled package cache..."
  fi
  function end_pacc {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Pulizia cache pacchetti disinstallati"
    else
      end_msg "$1" "Uninstalled packages cache cleaning"
    fi
  }
  if paccache -duk0 | grep -q "no candidate packages found for pruning"; then
    if [[ $_LNG = ita ]]; then
      echo "Pulizia cache non necessaria."
      end_pacc "skip"
    else
      echo "Cache cleaning not required."
      end_pacc "skip"
    fi
  else
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Desideri pulire completamente la cache dei pacchetti disinstallati" && sure=yes || sure=no
    else
      qst_msg "yes" "Do you want to completely clean the cache of uninstalled packages" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      if $_SUDO paccache -ruk0 --nocolor 2> >(print_errors); then
        end_pacc "ok"
      else
        end_pacc "no"
      fi
    else
      end_pacc "no"
    fi
  fi
  echo
  # Here we'll check for '.pacnew' files, then catch '.pacnew' files that are
  #  useless (there is 'foo.conf.pacnew' and not 'foo.conf'), finally warn the
  #  user about it.
  # Temporarely disable pipefail option, find often reports non critical errors.
  set +o pipefail
  local i=0
  local -a pacnews=""
  while IFS= read -r -d '' file; do
    pacnews[i++]="$file"
  done < <(find /etc -name "*.pacnew" -print0 2>>"$logfile")
  set -o pipefail
  local -a orphan_pacnews=""
  if [[ -n ${pacnews[0]} ]]; then
    local -i j=0
    for i in "${pacnews[@]}"; do
      local pacold=${i//\.pacnew/}
      if [[ ! -f "$pacold" ]]; then
        orphan_pacnews[j++]="$pacold.pacnew"
      fi
    done
  fi
  if [[ -n ${orphan_pacnews[0]} ]]; then
    echo
    for i in "${orphan_pacnews[@]}"; do
      echo "$i"
    done
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Sono presenti questi ${#orphan_pacnews[@]} file '.pacnew' orfani (consultare la documentazione [8] per maggiori informazioni), vuoi eliminarli" && sure=yes || sure=no
    else
      qst_msg "yes" "These are ${#orphan_pacnews[@]} orphan '.pacnew' files (read documentation [8] for further information), do you want to erase them" && sure=yes || sure=no
    fi
    function end_pnew {
      if [[ $_LNG = ita ]]; then
        end_msg "$1" "File di configurazione orfani"
      else
        end_msg "$1" "Orphan configuration files"
      fi
    }
    if [[ $sure != no ]]; then
      # shellcheck disable=SC2068
      if $_SUDO rm -f ${orphan_pacnews[@]} 2> >(print_errors); then
        end_pnew "ok"
      else
        end_pnew "no"
      fi
    else
      end_pnew "no"
    fi
  fi
  if [[ -n ${pacnews[0]} && ( ${#pacnews[@]} -gt ${#orphan_pacnews[@]} || -z ${orphan_pacnews[0]} ) ]]; then
    echo
    if [[ $_LNG = ita ]]; then
      end_msg "warn" "Sono presenti nuove versioni di alcuni file di configurazione. Valutare le modifiche tramite il comando 'pacdiff'. Consultare la documentazione [8] per maggiori informazioni."
    else
      end_msg "warn" "There are updated version of some configuration files. Assess the changes with the command 'pacdiff'. Read documentation [8] for further information."
    fi
  fi
}

#
# Function containing all file cleaning operation.
# Cache & thumbs cleaning, residual file cleaning, trash cleaning.
#
function clean_file {
  echo -e "\\nStart clean_file()\\n" >> "$logfile"
  if [[ $_LNG = ita ]]; then
    echo " ${_BOLD}::Pulizia file::${_NORMAL} "
  else
    echo " ${_BOLD}::Files cleaning::${_NORMAL} "
  fi
  if [[ "$(cat /proc/1/comm)" = systemd ]]; then
    echo
    function end_journal {
      if [[ $_LNG = ita ]]; then
        end_msg "$1" "Pulizia file di log"
      else
        end_msg "$1" "Log files cleaning"
      fi
    }
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "Desideri controllare la dimensione del journal log" && sure=yes || sure=no
    else
      qst_msg "yes" "Do you want to check journal log disk usage" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      if [[ $_LNG = ita ]]; then
        echo "Controllo della dimensione del journal log in corso..."
      else
        echo "Checking journal log disk usage..."
      fi
      local log_size
      # Check journal log files, consider realistic cases only order of MB and GB.
      if log_size=$($_SUDO journalctl --disk-usage 2>>"$logfile" | \
        sed -e "s/[a-z]//g" | sed -e "s/\\s\\+/ /g" | cut -d" " -f 2); then
        if echo "$log_size" | grep -q G ; then
          log_size=$(echo "1000*${log_size/[A-Z]/}" | bc)
        else
          log_size=${log_size/[A-Z]/}
        fi
        log_size=${log_size/\.*/}
        if [[ $log_size -ge 200 ]]; then
          if [[ $_LNG = ita ]]; then
            qst_msg "yes" "Potrebbe essere utile restringere il journal log, vuoi procedere" && sure=yes || sure=no
          else
            qst_msg "yes" "It may be useful to trim journal log, do you want to continue" && sure=yes || sure=no
          fi
          if [[ $sure != no ]]; then
            if $_SUDO journalctl --vacuum-size=200M \
              --vacuum-time=2weeks | tail -n 1 2> >(print_errors); then
              end_journal "ok"
            else
              end_journal "no"
            fi
          else
            end_journal "no"
          fi
        else
          if [[ $_LNG = ita ]]; then
            echo "I file di log non occupano eccessivo spazio su disco."
            end_journal "skip"
          else
            echo "Log files do not use significant disk space."
            end_journal "skip"
          fi
        fi
      else
        end_journal "no"
      fi
    else
      end_journal "no"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Controllo dei log obsoleti in corso..."
  else
    echo "Checking obsolete log files..."
  fi
  function end_log {
    if [[ $_LNG = ita ]]; then
      end_msg "$1" "Pulizia file di log obsoleti"
    else
      end_msg "$1" "Obsolete log files cleaning"
    fi
  }
  # Check classic log files, they are considered a thousand time heavier
  # because they are also obsolete if older than 90 days.
  # Temporarely disable pipefail option, find often reports non critical errors.
  set +o pipefail
  local i=0
  local -a obsoletelogs=""
  while IFS= read -r -d '' file; do
    obsoletelogs[i++]="$file"
  done < <(find /var/log -name journal -prune -o \( -type f -ctime +90 \
    -print0 \) 2>>"$logfile")
  set -o pipefail
  if [[ -n ${obsoletelogs[0]} ]]; then
    # Print every obsolete log file
    for i in "${obsoletelogs[@]}"; do
      echo "$i"
    done | column -x
    if [[ $_LNG = ita ]]; then
      qst_msg "no" "Ci sono ${#obsoletelogs[@]} file di log obsoleti, desideri rimuoverli" && sure=yes || sure=no
    else
      qst_msg "no" "There are ${#obsoletelogs[@]} obsolete log files, do you want to remove them" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      # Remove every residual file
      # shellcheck disable=SC2068
      if $_SUDO rm -f ${obsoletelogs[@]} 2> >(print_errors); then
        end_log "ok"
      else
        end_log "no"
      fi
    else
      end_log "no"
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non sono presenti file di log obsoleti."
      end_log "skip"
    else
      echo "There are no obsolete log files."
      end_log "skip"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Stima dello spazio occupato da cache e miniature poco recenti in"\
      "corso..."
  else
    echo "Calculating disk space taken by old cache and thumbnails..."
  fi
  # This part checks the existence of thumbnails and cache folders, then
  #  calculate the total space they take.
  # Disable pipefail option, because 'find' often exits with errors,
  #  but these are not critical.
  set +o pipefail
  local oldsize=0
  if [[ -d "$HOME/.thumbnails" ]]; then
    # shellcheck disable=SC2216
    oldsize=$(echo "$oldsize+$( find "$HOME/.thumbnails" -type f\
      -atime +30 -print0 2>>"$logfile" | du --files0-from=- -cb |\
      tail -1 | cut -f 1 )" | bc)
    # shellcheck disable=SC2216
    oldsize=$(echo "$oldsize+$( find "$HOME/.thumbnails" -empty -type d\
      -atime +30 -print0 2>>"$logfile" | du --files0-from=- -cb |\
      tail -1 | cut -f 1 )" | bc)
  fi
  if [[ -d "$HOME/.cache" ]]; then
    # shellcheck disable=SC2216
    oldsize=$(echo "$oldsize+$( find "$HOME/.cache" -type f -atime +30 -print0 \
      2>>"$logfile" | du --files0-from=- -cb | tail -1 | cut -f 1 )" | bc)
    # shellcheck disable=SC2216
    oldsize=$(echo "$oldsize+$( find "$HOME/.cache" -empty -type d -atime +30 \
      -print0 2>>"$logfile" | du --files0-from=- -cb | tail -1 | cut -f 1 )" \
      | bc)
  fi
  set -o pipefail
  if [[ $oldsize -gt 0 ]]; then
    oldsize=$(human_size "$oldsize")
    if [[ $_LNG = ita ]]; then
      qst_msg "yes" "L'eliminazione di questi file libererà $oldsize di spazio su disco, vuoi procedere" && sure=yes || sure=no
    else
      qst_msg "yes" "The deletion of these files frees $oldsize of disk space, do you want to continue" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      # Disable pipefail option because 'find' often report not critical errors
      set +o pipefail
      if [[ -d "$HOME/.thumbnails" ]]; then
        find "$HOME/.thumbnails" -type f -atime +30 -print0 2>/dev/null |\
          xargs -0 rm -f 2> >(print_errors)
        find "$HOME/.thumbnails" -empty -type d -atime +30\
          -print0 2>/dev/null | xargs -0 rm -rf 2> >(print_errors)
      fi
      if [[ -d "$HOME/.cache" ]]; then
        find "$HOME/.cache" -type f -atime +30 -print0 2>/dev/null | \
          xargs -0 rm -f 2> >(print_errors)
        find "$HOME/.cache" -empty -type d -atime +30 -print0 2>/dev/null | \
          xargs -0 rm -rf 2> >(print_errors)
      fi
      set -o pipefail
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia cache e miniature"
      else
        end_msg "ok" "Thumbs and cache cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia cache e miniature"
      else
        end_msg "no" "Thumbs and cache cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non c'è necessità di eliminare alcun"\
        "file, le cartelle sono sufficientemente pulite."
      end_msg "skip" "Pulizia cache e miniature"
    else
      echo "There is no need to delete any file,"\
        "these folders are pretty clean."
      end_msg "skip" "Thumbs and cache cleaning"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Ricerca di file residui in corso..."
  else
    echo "Searching residual file..."
  fi
  # Null separated output will be used just to have less problem with
  #  strange characters.
  # Bash pipefail option is disabled temporarly, see previous comments.
  set +o pipefail
  local i=0
  local -a residfiles=""
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o \( -type f -atime +1 -name "*~"\
    -user "$USER" -print0 \) 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o \( -type f -atime +1 -name ".*.swp"\
    -user "$USER" -print0 \) 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o -name "Desktop.ini" -user "$USER"\
    -print0 2>>"$logfile")
  while IFS= read -r -d '' file; do
    residfiles[i++]="$file"
  done < <(find "$HOME" -name "*Steam*" -prune -o -path\
    "$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
    -path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
    -o -path "*/.git" -prune -o -name "Thumbs.db" -user "$USER" -print0\
    2>>"$logfile")
  set -o pipefail
  if [[ -n ${residfiles[0]} ]]; then
    # Print every residual file
    for i in "${residfiles[@]}"; do
      echo "$i"
    done | column -x
    # Calculate space taken by residual files
    local residsize=0
    local filesize=0
    for i in "${residfiles[@]}"; do
      filesize=$( du -b "$i" | cut -f 1 )
      residsize=$( echo "$residsize+$filesize" | bc )
    done
    residsize=$(human_size "$residsize")
    if [[ $_LNG = ita ]]; then
      qst_msg "no" "Ci sono ${#residfiles[@]} file residui che occupano $residsize di spazio su disco, desideri rimuoverli" && sure=yes || sure=no
    else
      qst_msg "no" "There are ${#residfiles[@]} residual files that take $residsize of disk space, do you want to remove them" && sure=yes || sure=no
    fi
    if [[ $sure != no ]]; then
      # Remove every residual file
      for i in "${residfiles[@]}"; do
        rm -f "$i" 2> >(print_errors)
      done
      if [[ $_LNG = ita ]]; then
        end_msg "ok" "Pulizia file residui"
      else
        end_msg "ok" "Residual files cleaning"
      fi
    else
      if [[ $_LNG = ita ]]; then
        end_msg "no" "Pulizia file residui"
      else
        end_msg "no" "Residual files cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Non sono presenti file residui."
      end_msg "skip" "Pulizia file residui"
    else
      echo "There are no residual files."
      end_msg "skip" "Residual files cleaning"
    fi
  fi
  echo
  if [[ $_LNG = ita ]]; then
    echo "Stima dimensioni dei file nel cestino in corso..."
  else
    echo "Checking trash files size..."
  fi
  if [[ -d "$HOME/.local/share/Trash/files" ]]; then
    # Bash pipefail option is disabled temporarly, see previous comments.
    set +o pipefail
    local i=0
    local -a trashfiles=""
    while IFS= read -r -d '' file; do
      trashfiles[i++]="$file"
    done < <(find "$HOME/.local/share/Trash/files" -mindepth 1\
      -maxdepth 1 -print0 2>>"$logfile")
    set -o pipefail
    local trashsize=0
    if [[ -n ${trashfiles[0]} ]]; then
      local filename=""
      local filesize=0
      # This for loop counts total space taken by files and prints every
      #  file name next to the file size.
      for i in "${trashfiles[@]}"; do
        filename=$( basename "$i" )
        filesize=$( du -bs "$i" | cut -f 1 )
        trashsize=$( echo "$trashsize+$filesize" | bc )
        filesize=$( human_size "$filesize" )
        echo -ne "   $filesize   \\t"
        if [[ -d "$i" ]]; then
          filename+="/"
          echo "${_BOLD}$filename${_NORMAL}"
        else
          echo "$filename"
        fi
      done
      trashsize=$(human_size "$trashsize")
      if [[ $_LNG = ita ]]; then
        qst_msg "no" "Sono presenti ${#trashfiles[@]} elementi che occupano $trashsize di spazio sul disco, desideri eliminarli definitivamente" && sure=yes || sure=no
      else
        qst_msg "no" "There are ${#trashfiles[@]} items that take $trashsize of disk space, do you want do definetely delete them" && sure=yes || sure=no
      fi
      if [[ $sure != no ]]; then
        rm -rf "$HOME/.local/share/Trash/files" 2> >(print_errors)
        rm -rf "$HOME/.local/share/Trash/info" 2> >(print_errors)
        if [[ $_LNG = ita ]]; then
          end_msg "ok" "Pulizia cestino"
        else
          end_msg "ok" "Trash cleaning"
        fi
      else
        if [[ $_LNG = ita ]]; then
          end_msg "no" "Pulizia cestino"
        else
          end_msg "no" "Trash cleaning"
        fi
      fi
    else
      if [[ $_LNG = ita ]]; then
        echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
        end_msg "skip" "Pulizia cestino"
      else
        echo "Trash is completely empty, there is no need to clean it."
        end_msg "skip" "Trash cleaning"
      fi
    fi
  else
    if [[ $_LNG = ita ]]; then
      echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
      end_msg "skip" "Pulizia cestino"
    else
      echo "Trash is completely empty, there is no need to clean it."
      end_msg "skip" "Trash cleaning"
    fi
  fi
}

#
# Function containing pacman troubleshooting
#
function trouble_shoot {
  echo -e "\\nStart trouble_shoot()\\n" >> "$logfile"
  local again=true
  local twidth
  twidth=$(tput cols)
while [[ $again = true ]]; do
  clear
  if [[ $_LNG = ita ]]; then
    echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Indicare quale di"\
      "questi messaggi restituisce il gestore di pacchetti:\\n${_NORMAL}"\
      | fmt -w "$twidth"
    echo "${_BOLD}[1] ->${_NORMAL} errore: impossibile eseguire"\
      "l'operazione richiesta (file in conflitto)" | fmt -w "$twidth"
    echo "${_BOLD}[2] ->${_NORMAL} errore: impossibile eseguire"\
      "l'operazione richiesta (il pacchetto non è valido oppure è"\
      "corrotto (firma PGP))" | fmt -w "$twidth"
    echo "${_BOLD}[3] ->${_NORMAL} errore: impossibile scaricare il"\
      "pacchetto '...' da ..." | fmt -w "$twidth"
    echo "${_BOLD}[4] ->${_NORMAL} errore: impossibile bloccare il"\
      "database: File già esistente" | fmt -w "$twidth"
    echo "${_BOLD}[5] ->${_NORMAL} warning: pkgname: local (1.15.3-2) is newer"\
      "than reponame (1.15.3-1)" | fmt -w "$twidth"
    echo -e "\\nSe il problema non è qui elencato si consiglia di chiedere"\
      "aiuto sul forum online della propria distribuzione."\
      | fmt -w "$twidth"
    echo "${_BOLD}[q|0] ->${_NORMAL} Torna al menù principale"
    echo -en "\\n${_BOLD}Opzione: ${_NORMAL}"
    read -r -n1 sure
    case $sure in
      q|0)   again=false
        ;;
      1)  echo ; echo
        echo "Questo messaggio di errore compare quando il gestore"\
          "di pacchetti si accorge che per installare un determinato"\
          "pacchetto sarebbe necessario sovrascrivere un file già"\
          "presente nel sistema. Il nome del file in questione viene"\
          "stampato insieme al messaggio di errore." | fmt -w "$twidth"
        echo "Ci sono due possibili soluzioni:" | fmt -w "$twidth"
        echo "-> se vengono segnalati solo pochi file è possibile"\
          "rimuoverli manualmente tramite il comando 'sudo rm"\
          "/percorso/completo/file';" | fmt -w "$twidth"
        echo "-> se i file sono molto numerosi è possibile"\
          "automatizzare il processo dando al gestore di pacchetti"\
          "il permesso di sovrascrivere i file in conflitto, questa"\
          "opzione va utilizzata il meno possibile perché può avere"\
          "effetti collaterali anche gravi, per utilizzarla bisogna"\
          "lanciare il seguente comando di installazione fornendo il"\
          "nome del pacchetto che causa il problema e il percorso dei"\
          "file che causano il conflitto 'sudo pacman -S --overwrite"\
          "percorsofile nomepacchetto'. Per maggiori informazioni"\
          "consultare il manuale di 'pacman'." | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      2)  echo ; echo
        echo "Questo messaggio di errore segnala l'impossibilità di"\
          "verificare correttamente la provenienza di un pacchetto."\
          | fmt -w "$twidth"
        echo "Generalmente può essere risolto lanciando il seguenti"\
          "comandi:" | fmt -w "$twidth"
        echo "  sudo rm -r /etc/pacman.d/gnupg"
        echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
        echo "  sudo pacman-key --init"
        echo "  sudo pacman-key --populate arch manjaro"
        echo "  sudo pacman-key --refresh-keys"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      3)  echo ; echo
        echo "Questo messaggio di errore compare quando il gestore"\
          "di pacchetti non riesce a scaricare dai repository online"\
          "i database o i pacchetti richiesti." | fmt -w "$twidth"
        echo "La prima cosa da verificare è la corretta connessione"\
          "ad una rete internet del sistema in uso." | fmt -w "$twidth"
        echo "Se il sistema risulta connesso ad internet ma il"\
          "problema persiste è probabile che il gestore di pacchetti"\
          "si stia rivolgendo ad un server non funzionante oppure"\
          "obsoleto, è quindi necessario generare una nuova lista"\
          "dei mirror; sui sistemi Manjaro Linux è possibile farlo"\
          "tramite 'pacman-mirrors'." | fmt -w "$twidth"
        echo "Il comando consigliato per generare velocemente una"\
          "nuova lista dei mirror è 'sudo pacman-mirrors -f10'."\
          | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      4)  echo ; echo
        echo "Questo messaggio di errore segnala la presenza di un"\
          "file di lock, che indica un'operazione in corso da parte"\
          "del gestore di pacchetti, a volte questo file non viene"\
          "correttamente cancellato e rimane nonostante non ci sia"\
          "alcuna operazione in corso." | fmt -w "$twidth"
        echo "Dopo aver controllato che non ci sia alcun processo"\
          "di installazione/aggiornamento in atto (sia da parte di"\
          "pacman sia da parte dei gestori software da interfaccia"\
          "grafica) è possibile eliminare il file di lock lanciando"\
          "il comando 'sudo rm /var/lib/pacman/db.lck'."\
          | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      5)  echo ; echo
        echo "Questo messaggio avverte l'utente che un pacchetto tra"\
          "quelli installati è ad una versione più recente di quella"\
          "presente nei repository di riferimento della propria"\
          "distribuzione. La scelta migliore è di reinstallare il"\
          "pacchetto indicato nel messaggio, se i pacchetti sono più"\
          "di uno è possibile reinstallarli manualmente uno per volta"\
          "oppure eseguire una sincronizzazione automatica con le versioni"\
          "nei repository attraverso il comando 'sudo pacman -Syuu'."\
          | fmt -w "$twidth"
        echo
        echo -n "Premi un tasto qualsiasi per continuare. "
        read -rs -n1
        ;;
      *)  echo ; echo
        echo -n "Non esiste l'opzione '$sure'. Premi un tasto"\
          "qualsiasi per continuare. " | fmt -w "$twidth"
        read -rs -n1
    esac
  else
    echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Select the error"\
      "message printed by the package manager:\\n${_NORMAL}"\
      | fmt -w "$twidth"
    echo "${_BOLD}[1] ->${_NORMAL} error: failed to commit transaction"\
      "(conflicting files)" | fmt -w "$twidth"
    echo "${_BOLD}[2] ->${_NORMAL} error: failed to commit transaction"\
      "(invalid or corrupted package (PGP signature))" | fmt -w "$twidth"
    echo "${_BOLD}[3] ->${_NORMAL} error: failed retrieving file '...'"\
      "from ..." | fmt -w "$twidth"
    echo "${_BOLD}[4] ->${_NORMAL} error: failed to init transaction"\
      "(unable to lock database)" | fmt -w "$twidth"
    echo "${_BOLD}[5] ->${_NORMAL} warning: pkgname: local (1.15.3-2) is newer"\
      "than reponame (1.15.3-1)" | fmt -w "$twidth"
    echo -e "\\nIf the problem is not listed here ask to your"\
      "distribution's online forum for help." | fmt -w "$twidth"
    echo "${_BOLD}[q|0] ->${_NORMAL} Return to main menu"
    echo -en "\\n${_BOLD}Option: ${_NORMAL}"
    read -r -n1 sure
    case $sure in
      q|0)   again=false
        ;;
      1)  echo ; echo
        echo "This error message appears when the pckage manager needs"\
          "to overwrite an existing file in order to install a"\
          "certain package. The file name is printed in the error"\
          "message." | fmt -w "$twidth"
        echo "There are two possible solutions:"
        echo "-> if there are only a few conflicting files, they can"\
          "be removed manually with 'sudo rm /path/to/file';"\
          | fmt -w "$twidth"
        echo "-> if there are many conflicting files it is possible to"\
          "give pacman permission to overwrite them; however this"\
          "option can be dangerous and should be used only when"\
          "necessary; to use it read from the error message the name"\
          "of the package and the path to conflicting files, then"\
          "execute 'sudo pacman -S --overwrite pathtofile packagename'."\
          "More information in 'pacman' manual." | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      2)  echo ; echo
        echo "This error message appears if pacman fails to verify the"\
          "source of a package." | fmt -w "$twidth"
        echo "These commands should solve the problem:"
        echo "  sudo rm -r /etc/pacman.d/gnupg"
        echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
        echo "  sudo pacman-key --init"
        echo "  sudo pacman-key --populate arch manjaro"
        echo "  sudo pacman-key --refresh-keys"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      3)  echo ; echo
        echo "This error message appears if pacman fails to download"\
          "needed packages or database from online repository."\
          | fmt -w "$twidth"
        echo "Verify first that your system is properly connected to a"\
          "network." | fmt -w "$twidth"
        echo "If the problem persists, it is possible that pacman is"\
          "trying to download files from a non working or obsolete"\
          "server, in this case the mirror list should be updated;"\
          "in a Manjaro Linux system you can use 'pacman-mirrors' to"\
          "accomplish that." | fmt -w "$twidth"
        echo "To generate a new mirrorlist in few seconds the"\
          "suggested command is 'sudo pacman-mirrors -f10'."\
          | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      4)  echo ; echo
        echo "This error message appears when pacman finds a lock"\
          "file, which indicates that a package management"\
          "transaction is in progress; however sometimes such files"\
          "remain also after the transaction is finished."\
          | fmt -w "$twidth"
        echo "After making sure that no package management process"\
          "(from pacman or from any graphical package management"\
          "software) is in progress, then the lock file can be"\
          "removed launching 'sudo rm /var/lib/pacman/db.lck'."\
          | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      5)  echo ; echo
        echo "This warning message appears when an installed package"\
          "has a version newer than the one in your distribution's"\
          "repository. The simplest solution is to reinstall the"\
          "package mentioned in the warning message, if there are"\
          "multiple packages in this situation you can reinstall them"\
          "one by one manually or launch an automatic synchronization"\
          "with the repository with the command 'sudo pacman -Syuu'."\
          | fmt -w "$twidth"
        echo
        echo -n "Press any key to continue. "
        read -rs -n1
        ;;
      *)  echo ; echo
        echo -n "There is no '$sure' option. Press any key to"\
          "continue. " | fmt -w "$twidth"
        read -rs -n1
    esac
  fi
done
}

#
# This function prints the menu and handles choice of different options.
#
function main {
  local sure
  while true; do
    clear
    unset sure

    echo
    echo "                ┌─── ┐   ┐"
    echo "                │    │   │"
    echo "                └────└───┘"
    echo "            cleanupdate v0.8.1"
    if [[ $_LNG = ita ]]; then
      echo " ┌────────────────────────────────────────┐"
      echo " │    1.  Aggiorna e pulisci tutto        │"
      echo " │    2.  Aggiorna il sistema             │"
      echo " │    3.  Pulisci i pacchetti             │"
      echo " │    4.  Pulisci i file                  │"
      echo " │                                        │"
      echo " │    7.  Risoluzione problemi frequenti  │"
      echo " │    8.  Documentazione                  │"
      echo " │    9.  Cambia lingua (eng|${_BOLD}ita${_NORMAL})         │"
      echo " │  q|0.  ESCI                            │"
      echo " └────────────────────────────────────────┘"
      echo
      echo -n " Seleziona un'opzione : "
    else
      echo " ┌────────────────────────────────────────┐"
      echo " │    1.  Update and clean everything     │"
      echo " │    2.  Update system                   │"
      echo " │    3.  Clean packages                  │"
      echo " │    4.  Clean files                     │"
      echo " │                                        │"
      echo " │    7.  Solve commmon errors            │"
      echo " │    8.  Documentation                   │"
      echo " │    9.  Change language (${_BOLD}eng${_NORMAL}|ita)       │"
      echo " │  q|0.  QUIT                            │"
      echo " └────────────────────────────────────────┘"
      echo
      echo -n " Select an option : "
    fi
    read -rs -n1 sure
    case $sure in
      1)
        clear
        sys_update
        echo
        clean_pkg
        echo
        clean_file
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      2)
        clear
        sys_update
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      3)
        clear
        clean_pkg
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      4)
        clear
        clean_file
        echo
        if [[ $_LNG = ita ]]; then
          echo -n "Finito! Premi un tasto qualsiasi per continuare. "
        else
          echo -n "Finished! Press any key to continue. "
        fi
        read -rs -n1
        ;;
      7)
        clear
        trouble_shoot
        ;;
      8)
        clear
        if [[ $_LNG = ita ]]; then
          if ! man -L it -E UTF-8 cleanupdate 2> >(print_errors); then
            echo "Controllare le impostazioni di lingua del"\
              "sistema." | print_errors
            echo -n "Premi un tasto qualsiasi per continuare."
            read -rs -n1
          fi
        else
          if ! man -L en -E UTF-8 cleanupdate 2> >(print_errors); then
            echo "Check the system's locale setting." | print_errors
            echo -n "Press any key to continue. "
            read -rs -n1
          fi
        fi
        ;;
      9)
        if [[ $_LNG = ita ]]; then
          _LNG="eng"
        else
          _LNG="ita"
        fi
        ;;
      q|0)
        # Clear trap rules
        trap - EXIT
        # Clear terminal, scrollback included
        clear && echo -en "\\e[3J"
        exit 0
        ;;
      *)
        echo
        echo
        if [[ $_LNG = ita ]]; then
          echo -n " Non esiste l'opzione '$sure'. Premi un tasto"\
            "qualsiasi per continuare. "
        else
          echo -n " There is no '$sure' option. Press any key to"\
            "continue. "
        fi
        read -rs -n1
    esac
  done
}

# Here begins the "main script"

# Enable debug
#set -x

# Initialise logfile with current date and time.
logfile="/tmp/cleanupdate.log"
echo -e "\\n$(date -R) --- Cleanupdate errors log\\n" >> "$logfile"

check_args "$@"

# Launch the long search for residual file and put everything in background,
#  this way the second execution will be faster on hard disk, because everything
#  is already in cache.
if ! (find "$HOME" -name "*Steam*" -prune -o -path "$HOME/.cache" -prune -o\
  -path "$HOME/.thumbnails" -prune -o -path "$HOME/.mozilla" -prune -o\
  -path "$HOME/.thunderbird" -prune -o -path "*/.git" -prune -o\
  -print >/dev/null 2>>"$logfile" &) ; then
  echo "Errors running initial background 'find' job." >> "$logfile"
fi

main

# Disable debug
#set +x

exit 1
