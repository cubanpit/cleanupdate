#!/bin/bash
#
# 'cleanupdate' by cubanpit at github.com
#
# Initial script found somewhere on internet (thanks to unknown).
# Menu taken from a script by Chrysostomus.
#
# This script should help you to maintain an ArchLinux-based system.
# Report issue at github.com/cubanpit/cleanupdate
#
################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# Define some useful text style and color
_BOLD=$(/bin/tput bold)
_NORMAL=$(/bin/tput sgr0)
_RED=$(/bin/tput setaf 1)
_GREEN=$(/bin/tput setaf 2)
_YELLOW=$(/bin/tput setaf 3)
_AQUA=$(/bin/tput setaf 6)
readonly _BOLD _NORMAL _RED _GREEN _YELLOW _AQUA

# Default language is English, but Italian it's available
_LNG="eng"
[[ "$LANG" =~ "it_IT" ]] && _LNG="ita"

# If user is not root, then you need 'sudo'
if [[ "$(id -u)" = "0" ]]
then
	declare -r _SUDO=""
else
	declare -r _SUDO="sudo"
fi

#
# Function to convert file size in a format easier to read, it receives file
#  size in bytes.
# Usage: human_size "size in bytes"
#
function human_size {
	_NUM=$1
	if [[ _NUM -ge 1000000000 ]]; then
		_NUM="$(( _NUM / 1000000000 )) GB"
	elif [[ _NUM -ge 1000000 ]]; then
		_NUM="$(( _NUM / 1000000 )) MB"
	elif [[ _NUM -ge 1000 ]]; then
		_NUM="$(( _NUM / 1000 )) kB"
	elif [[ _NUM -ge 0 ]]; then
		_NUM="$_NUM B"
	else
		[[ $_LNG = ita ]] && echo "ERRORE: impossibile convertire numeri negativi."
		[[ $_LNG = eng ]] && echo "ERROR: it's not possible to convert negative numbers."
	fi
	echo "$_NUM"
}

#
# Function to print a message after a transaction, communicating if it has been
#  executed, has been cenceled or has been skipped because unuseful.
# Usage: end_msg "ok||no||skip||warn" "message"
#
function end_msg {
	_MOD=$1
	_MSG=$2
	if [[ $_MOD = ok ]]; then
		[[ $_LNG = ita ]] && echo "${_BOLD}[${_GREEN}ESEGUITO${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
		[[ $_LNG = eng ]] && echo "${_BOLD}[${_GREEN}DONE${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
	elif [[ $_MOD = no ]]; then
		[[ $_LNG = ita ]] && echo "${_BOLD}[${_RED}ANNULLATO${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
		[[ $_LNG = eng ]] && echo "${_BOLD}[${_RED}CANCELED${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
	elif [[ $_MOD = skip ]]; then
		[[ $_LNG = ita ]] && echo "${_BOLD}[${_AQUA}SALTATO${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
		[[ $_LNG = eng ]] && echo "${_BOLD}[${_AQUA}SKIPPED${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
	elif [[ $_MOD = warn ]]; then
		[[ $_LNG = ita ]] && echo "${_BOLD}[${_YELLOW}ATTENZIONE${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
		[[ $_LNG = eng ]] && echo "${_BOLD}[${_YELLOW}WARNING${_NORMAL}${_BOLD}] $_MSG ${_NORMAL}"
	else
		[[ $_LNG = ita ]] && echo "ERRORE: modalità sconosciuta, vedere funzione end_msg()."
		[[ $_LNG = eng ]] && echo "ERROR: unknown option, see end_msg() function."
	fi
}

#
# Function to print a question, setting the default answer.
# Usage: qst_msg "yes||no" "question"
#
function qst_msg {
	_MOD=$1
	_MSG=$2
	if [[ $_MOD = yes ]]; then
		[[ $_LNG = ita ]] && echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} $_MSG [S/n]?${_NORMAL} "
		[[ $_LNG = eng ]] && echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} $_MSG [Y/n]?${_NORMAL} "
	elif [[ $_MOD = no ]]; then
		[[ $_LNG = ita ]] && echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} $_MSG [s/N]?${_NORMAL} "
		[[ $_LNG = eng ]] && echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} $_MSG [y/N]?${_NORMAL} "
	else
		[[ $_LNG = ita ]] && echo "ERRORE: risposta predefinita sconosciuta, vedere funzione qst_msg()."
		[[ $_LNG = eng ]] && echo "ERROR: unknown default answer, see qst_msg() function."
	fi
}

#
# Function containing all system update operation.
# Database sync, package upgrade, AUR upgrade.
#
function sys_update {
	[[ $_LNG = ita ]] && echo " ${_BOLD}::Aggiornamento del sistema::${_NORMAL} "
	[[ $_LNG = eng ]] && echo " ${_BOLD}::System update::${_NORMAL} "
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri aggiornare i pacchetti ufficiali"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to upgrade official packages"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		_DISTRO=$(/bin/grep -i manjaro /etc/lsb-release)
		if [[ -n $_DISTRO &&\
				"$(stat /etc/pacman.d/mirrorlist | grep 'Modify' | cut -d' ' -f2)"\
				!= "$(date +%Y-%m-%d)" ]]; then
			$_SUDO /bin/pacman-mirrors -f10
			$_SUDO /bin/pacman -Syyu --color always
		else
			$_SUDO /bin/pacman -Syu --color always
		fi
		[[ $_LNG = ita ]] && end_msg "ok" "Aggiornamento pacchetti ufficiali"
		[[ $_LNG = eng ]] && end_msg "ok" "Official packages upgrade"
	else
		[[ $_LNG = ita ]] && end_msg "no" "Aggiornamento pacchetti ufficiali"
		[[ $_LNG = eng ]] && end_msg "no" "Official packages upgrade"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri aggiornare i pacchetti di AUR"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to upgrade AUR packages"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# Look for orphan packages, they could be pkgs removed from repositories
		#  and moved to AUR, better not to upgrade them silently.
		_ORP=$(/bin/pacman -Qdtq)
		if [[ -n $_ORP ]]; then
			[[ $_LNG = ita ]] && end_msg "warn" "Sono presenti pacchetti orfani, se non sono stati installati volontariamente ne è consigliata la rimozione."
			[[ $_LNG = eng ]] && end_msg "warn" "There are orphan packages, if you haven't installed them explicitly it's a good choice to remove them."
			$_SUDO /bin/pacman --color always -Rs $_ORP
		fi
		# Check if pacaur or yaourt are installed
		_PAC=$( /bin/pacman -Q pacaur 2> /dev/null )
		_YAU=$( /bin/pacman -Q yaourt 2> /dev/null )
		if [[ -n $_PAC ]]; then
			/bin/pacaur -Syua --color always
			[[ $_LNG = ita ]] && end_msg "ok" "Aggiornamento AUR"
			[[ $_LNG = eng ]] && end_msg "ok" "AUR upgrade"
		elif [[ -n $_YAU ]]; then
			/bin/yaourt -Sua --color
			[[ $_LNG = ita ]] && end_msg "ok" "Aggiornamento AUR"
			[[ $_LNG = eng ]] && end_msg "ok" "AUR upgrade"
		else
			[[ $_LNG = ita ]] && echo "Non risulta installato né 'yaourt' né 'pacaur',"\
				"non è possibile accedere agli aggiornamenti AUR tramite questo script."
			[[ $_LNG = eng ]] && echo "You don't have neither 'yaourt' nor 'pacaur' installed,"\
				"you can't access AUR updates through this script."
			[[ $_LNG = ita ]] && end_msg "skip" "Aggiornamento AUR"
			[[ $_LNG = eng ]] && end_msg "skip" "AUR upgrade"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Aggiornamento AUR"
		[[ $_LNG = eng ]] && end_msg "no" "AUR upgrade"
	fi
}

#
# Function containing all package cleaning operation.
# Orphaned packages cleaning, cache cleaning, database optimization.
#
function clean_pkg {
	[[ $_LNG = ita ]] && echo " ${_BOLD}::Pulizia pacchetti::${_NORMAL} "
	[[ $_LNG = eng ]] && echo " ${_BOLD}::Packages cleaning::${_NORMAL} "
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri cercare pacchetti orfani?"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want search for orphaned packages"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		_ORP=$(/bin/pacman -Qdtq)
		if [[ -n $_ORP ]]; then
			$_SUDO /bin/pacman --color always -Rs $_ORP
			[[ $_LNG = ita ]] && end_msg "ok" "Pacchetti orfani"
			[[ $_LNG = eng ]] && end_msg "ok" "Orphaned packages"
		else
			[[ $_LNG = ita ]] && echo "Non è presente alcun pacchetto orfano."
			[[ $_LNG = eng ]] && echo "There isn't any orphaned packages."
			[[ $_LNG = ita ]] && end_msg "skip" "Pacchetti orfani"
			[[ $_LNG = eng ]] && end_msg "skip" "Orphaned packages"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pacchetti orfani"
		[[ $_LNG = eng ]] && end_msg "no" "Orphaned packages"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri pulire la cache dei pacchetti installati (conservando le ultime 2 versioni)"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to clean the cache of installed packages (keeping 2 versions)"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		$_SUDO /bin/paccache -rk2 --nocolor
		[[ $_LNG = ita ]] && end_msg "ok" "Pulizia cache pacchetti installati"
		[[ $_LNG = eng ]] && end_msg "ok" "Installed packages cache cleaning"
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pulizia cache pacchetti installati"
		[[ $_LNG = eng ]] && end_msg "no" "Installed packages cache cleaning"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri pulire completamente la cache dei pacchetti non installati"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to completely clean the cache of uninstalled packages"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		$_SUDO /bin/paccache -ruk0 --nocolor
		[[ $_LNG = ita ]] && end_msg "ok" "Pulizia cache pacchetti non installati"
		[[ $_LNG = eng ]] && end_msg "ok" "Uninstalled packages cache cleaning"
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pulizia cache pacchetti non installati"
		[[ $_LNG = eng ]] && end_msg "no" "Uninstalled packages cache cleaning"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri ottimizzare (deframmentare) il database di pacman"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to optimize (defragment) pacman database"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# This part of the script try to check if the disk containing
		#  pacman database is a solid state drive.
		_ROTAT=false
		if [[ -d "/var/lib/pacman" ]]; then # check database existence
			# Find disk on which database is located
			_DISK=$(/bin/df -P /var/lib/pacman | /bin/tail -n 1 | /bin/cut -d' ' -f 1 | \
					/bin/sed -E 's/(\/dev\/|[0-9])//g')
			# Discover if database disk exist as device and is rotational
			[[ -n $_DISK && -b "/dev/$_DISK" && \
			-e "/sys/block/$_DISK/queue/rotational" && \
			$(/bin/cat "/sys/block/$_DISK/queue/rotational") -eq 1 ]] && _ROTAT=true
		fi
		if [[ "$_ROTAT" = true ]]; then
			$_SUDO /bin/pacman-optimize --nocolor
			[[ $_LNG = ita ]] && end_msg "ok" "Ottimizzazione database"
			[[ $_LNG = eng ]] && end_msg "ok" "Database optimization"
		else
			[[ $_LNG = ita ]] && echo "Il database di pacman non risiede su un "\
				"disco rotazionale, non è necessario eseguire la deframmentazione."
			[[ $_LNG = eng ]] && echo "The pacman database lives on a non "\
				"rotational disk, defragmentation is not needed."
			[[ $_LNG = ita ]] && end_msg "skip" "Ottimizzazione database"
			[[ $_LNG = eng ]] && end_msg "skip" "Database optimization"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Ottimizzazione database"
		[[ $_LNG = eng ]] && end_msg "no" "Database optimization"
	fi
	# Here we'll check for '.pacnew' files, then catch '.pacnew' files that are
	#  useless (there is 'foo.conf.pacnew' and not 'foo.conf'), finally warn the
	#  user about it.
	unset i
	while IFS= read -r -d '' file; do
		_PACNEW[i++]="$file"
	done < <(/bin/find /etc -name "*.pacnew" -print0 2>/dev/null)
	unset j
	for i in "${_PACNEW[@]}"; do
		_PACCONF=${i//\.pacnew/}
		[[ -f "$_PACCONF" ]] || _ORPHPACNEW[j++]="$_PACCONF.pacnew"
	done
	[[ ${#_PACNEW[@]} -eq ${#_ORPHPACNEW[@]} || ${#_PACNEW[@]} -eq 0 ]] && _PACNCTRL=false || _PACNCTRL=true
	if [[ ${#_ORPHPACNEW[@]} -gt 0 ]]; then
		echo
		for i in "${_ORPHPACNEW[@]}"; do
			echo "$i"
		done
		[[ $_LNG = ita ]] && qst_msg "yes" "Sono presenti questi ${#_ORPHPACNEW[@]} file '.pacnew' orfani (consultare la documentazione [8] per maggiori informazioni), vuoi eliminarli"
		[[ $_LNG = eng ]] && qst_msg "yes" "These are ${#_ORPHPACNEW[@]} orphan '.pacnew' files (read documentation [8] for further information), do you want to erase them"
		read -r _SURE
		if [[ $_SURE != "n" && $_SURE != "N" ]]; then
			for i in "${_ORPHPACNEW[@]}"; do
				$_SUDO /bin/rm -f "$i"
			done
			[[ $_LNG = ita ]] && end_msg "ok" "File di configurazione orfani"
			[[ $_LNG = eng ]] && end_msg "ok" "Orphan configuration files"
		else
			[[ $_LNG = ita ]] && end_msg "no" "File di configurazione orfani"
			[[ $_LNG = eng ]] && end_msg "no" "Orphan configuration files"
		fi
	fi
	if [[ $_PACNCTRL = true ]]; then
		echo
		[[ $_LNG = ita ]] && end_msg "warn" "Sono presenti nuove versioni di alcuni file di configurazione. Valutare le modifiche tramite il comando 'pacdiff'. Consultare la documentazione [8] per maggiori informazioni."
		[[ $_LNG = eng ]] && end_msg "warn" "There are updated version of some configuration files. Assess the changes with the command 'pacdiff'. Read documentation [8] for further information."
	fi
}

#
# Function containing all file cleaning operation.
# Cache & thumbs cleaning, residual file cleaning, trash cleaning.
#
function clean_file {
	[[ $_LNG = ita ]] && echo " ${_BOLD}::Pulizia file::${_NORMAL} "
	[[ $_LNG = eng ]] && echo " ${_BOLD}::Files cleaning::${_NORMAL} "
	if [[ "$(/bin/cat /proc/1/comm)" = systemd ]]; then
		echo
		[[ $_LNG = ita ]] && qst_msg "yes" "Desideri ripulire i file di log per guadagnare spazio su disco"
		[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to clean log files to save disk space"
		read -r _SURE
		if [[ $_SURE != "n" && $_SURE != "N" ]]; then
			$_SUDO /bin/journalctl --vacuum-size=200M --vacuum-time=2weeks
			[[ $_LNG = ita ]] && end_msg "ok" "Pulizia file di log"
			[[ $_LNG = eng ]] && end_msg "ok" "Log files cleaning"
		else
			[[ $_LNG = ita ]] && end_msg "no" "Pulizia file di log"
			[[ $_LNG = eng ]] && end_msg "no" "Log files cleaning"
		fi
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri stimare lo spazio occupato dai file poco recenti nella cache e tra le miniature"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to estimate disk space taken by old cache and thumbnails"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# This part checks the existence of thumbnails and cache folders, then
		#  calculate the total space they take.
		_OLD=0
		[[ -d ~/.thumbnails ]] && (( _OLD+=$( /bin/find ~/.thumbnails -type f -atime +30 -print0 |\
						/bin/du --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 ) ))
		[[ -d ~/.thumbnails ]] && (( _OLD+=$( /bin/find ~/.thumbnails -empty -type d -atime +30 -print0 |\
						/bin/du --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 ) ))
		[[ -d ~/.cache ]] && (( _OLD+=$( /bin/find ~/.cache -type f -atime +30 -print0 |\
						/bin/du --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 ) ))
		[[ -d ~/.cache ]] && (( _OLD+=$( /bin/find ~/.cache -empty -type d -atime +30 -print0 |\
						/bin/du --files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 ) ))
		if [[ $_OLD -gt 0 ]]; then
			_OLD=$(human_size "$_OLD")
			[[ $_LNG = ita ]] && qst_msg "yes" "L'eliminazione di questi file libererà $_OLD di spazio su disco, vuoi procedere"
			[[ $_LNG = eng ]] && qst_msg "yes" "The deletion of these files frees $_OLD of disk space, do you want to continue"
			read -r _SURE
			if [[ $_SURE != "n" && $_SURE != "N" ]]; then
				[[ -d ~/.thumbnails ]] && /bin/find ~/.thumbnails -type f \
					-atime +30 -print0 | xargs -0 /bin/rm -f
				[[ -d ~/.cache ]] && /bin/find ~/.cache -name 'pacaur' -prune \
					-o \( -type f -atime +30 -print0 \)  | xargs -0 /bin/rm -f
				[[ -d ~/.thumbnails ]] && /bin/find ~/.thumbnails -empty \
					-type d -atime +30 -print0 | xargs -0 /bin/rm -rf
				[[ -d ~/.cache ]] && /bin/find ~/.cache -name 'pacaur' -prune \
					-o \( -empty -type d -atime +30 -print0 \) | xargs -0 /bin/rm -rf
				[[ $_LNG = ita ]] && end_msg "ok" "Pulizia cache e miniature"
				[[ $_LNG = eng ]] && end_msg "ok" "Thumbs and cache cleaning"
			else
				[[ $_LNG = ita ]] && end_msg "no" "Pulizia cache e miniature"
				[[ $_LNG = eng ]] && end_msg "no" "Thumbs and cache cleaning"
			fi
		else
			[[ $_LNG = ita ]] && echo "Non c'è necessità di eliminare alcun"\
				"file, le cartelle sono sufficientemente pulite."
			[[ $_LNG = eng ]] && echo "There is no need to delete any files,"\
				"these folders are pretty clean."
			[[ $_LNG = ita ]] && end_msg "skip" "Pulizia cache e miniature"
			[[ $_LNG = eng ]] && end_msg "skip" "Thumbs and cache cleaning"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pulizia cache e miniature"
		[[ $_LNG = eng ]] && end_msg "no" "Thumbs and cache cleaning"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri cercare file residui"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to search for residual files"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		# Null separated output will be used just to have less problem with
		#  strange characters.
		unset i
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "*~" -user "$USER" -print0 2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name ".*.swp" -user "$USER" -print0 2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "Desktop.ini" -user "$USER" -print0 2>/dev/null)
		while IFS= read -r -d '' file; do
			_RES[i++]="$file"
		done < <(/bin/find "$HOME" -name "Thumbs.db" -user "$USER" -print0 2>/dev/null)
		if [[ ${#_RES[@]} -gt 0 ]]; then
			# Print every residual file
			for i in "${_RES[@]}"; do
				echo "$i"
			done
			# Calculate space taken by residual files
			_RESP=0
			for i in "${_RES[@]}"; do
				(( _RESP+=$( /bin/du -b "$i" | /bin/cut -f 1 ) ))
			done
			_RESP=$(human_size "$_RESP")
			[[ $_LNG = ita ]] && qst_msg "no" "Ci sono ${#_RES[@]} file residui che occupano $_RESP di spazio su disco, desideri rimuoverli"
			[[ $_LNG = eng ]] && qst_msg "no" "There are ${#_RES[@]} residual files that take $_RESP of disk space, do you want to remove them"
			read -r _SURE
			if [[ ( $_LNG = eng && ( $_SURE = y || $_SURE = Y ) ) || \
				( $_LNG = ita && ( $_SURE = s || $_SURE = S ) ) ]]; then
				# Remove every residual file
				for i in "${_RES[@]}"; do
					/bin/rm -f "$i"
				done
				[[ $_LNG = ita ]] && end_msg "ok" "Pulizia file residui"
				[[ $_LNG = eng ]] && end_msg "ok" "Residual files cleaning"
			else
				[[ $_LNG = ita ]] && end_msg "no" "Pulizia file residui"
				[[ $_LNG = eng ]] && end_msg "no" "Residual files cleaning"
			fi
		else
			[[ $_LNG = ita ]] && echo "Non sono presenti file residui."
			[[ $_LNG = eng ]] && echo "There are no residual files."
		[[ $_LNG = ita ]] && end_msg "skip" "Pulizia file residui"
		[[ $_LNG = eng ]] && end_msg "skip" "Residual files cleaning"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pulizia file residui"
		[[ $_LNG = eng ]] && end_msg "no" "Residual files search"
	fi
	echo
	[[ $_LNG = ita ]] && qst_msg "yes" "Desideri controllare lo stato del cestino"
	[[ $_LNG = eng ]] && qst_msg "yes" "Do you want to check trash status"
	read -r _SURE
	if [[ $_SURE != "n" && $_SURE != "N" ]]; then
		if [[ -d ~/.local/share/Trash/files ]]; then
			unset i
			while IFS= read -r -d '' file; do
				_TRASH[i++]="$file"
			done < <(/bin/find ~/.local/share/Trash/files -mindepth 1 -maxdepth 1 -print0 2>/dev/null)
			# This for loop counts total space taken by files and prints every
			#  file name next to the file size.
			_TRASP=0
			for i in "${_TRASH[@]}"; do
				_FILENAME=$(basename "$i")
				_FILESIZE=$(/bin/du -bs "$i" | /bin/cut -f 1)
				(( _TRASP+=_FILESIZE ))
				_FILESIZE=$(human_size "$_FILESIZE")
				echo -ne "   $_FILESIZE   \t"
				if [[ -d "$i" ]]; then
					_FILENAME+="/"
					echo "${_BOLD}$_FILENAME${_NORMAL}"
				else
					echo "$_FILENAME"
				fi
			done
			if [[ ${#_TRASH[@]} -gt 0 ]]; then
				_TRASP=$(human_size "$_TRASP")
				[[ $_LNG = ita ]] && qst_msg "no" "Sono presenti ${#_TRASH[@]} elementi che occupano $_TRASP di spazio sul disco, desideri eliminarli definitivamente"
				[[ $_LNG = eng ]] && qst_msg "no" "There are ${#_TRASH[@]} items that take $_TRASP of disk space, do you want do definetely delete them"
				read -r _SURE
				if [[ ( $_LNG = eng && ( $_SURE = y || $_SURE = Y ) ) || \
					( $_LNG = ita && ( $_SURE = s || $_SURE = S ) ) ]]; then
					/bin/rm -rf ~/.local/share/Trash/*
					[[ $_LNG = ita ]] && end_msg "ok" "Pulizia cestino"
					[[ $_LNG = eng ]] && end_msg "ok" "Trash cleaning"
				else
					[[ $_LNG = ita ]] && end_msg "no" "Pulizia cestino"
					[[ $_LNG = eng ]] && end_msg "no" "Trash cleaning"
				fi
			else
				[[ $_LNG = ita ]] && echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
				[[ $_LNG = eng ]] && echo "Trash is completely empty, there is no need to clean it."
				[[ $_LNG = ita ]] && end_msg "skip" "Pulizia cestino"
				[[ $_LNG = eng ]] && end_msg "skip" "Trash cleaning"
			fi
		else
			[[ $_LNG = ita ]] && echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
			[[ $_LNG = eng ]] && echo "Trash is completely empty, there is no need to clean it."
			[[ $_LNG = ita ]] && end_msg "skip" "Pulizia cestino"
			[[ $_LNG = eng ]] && end_msg "skip" "Trash cleaning"
		fi
	else
		[[ $_LNG = ita ]] && end_msg "no" "Pulizia cestino"
		[[ $_LNG = eng ]] && end_msg "no" "Trash cleaning"
	fi
}

#
# Function containing pacman troubleshooting
#
function trouble_shoot {
	if [[ $_LNG = ita ]]; then
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Indicare quale di questi"\
			"messaggi restituisce il gestore di pacchetti:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (file in conflitto)"
		echo "${_BOLD}[2] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (il pacchetto non è valido oppure è"
			"corrotto (firma PGP))"
		echo "${_BOLD}[3] ->${_NORMAL} errore: impossibile scaricare il"\
			"pacchetto '...' da ..."
		echo "${_BOLD}[4] ->${_NORMAL} errore: impossibile bloccare il"\
			"database: File già esistente"
		echo -e "\nSe il problema non è qui elencato si consiglia di chiedere"\
			"aiuto sul forum online della propria distribuzione."
		echo "${_BOLD}[0] ->${_NORMAL} Torna al menù principale"
		echo -en "\n${_BOLD}Numero: ${_NORMAL}"
		read -r -n1 _SURE
		case $_SURE in
			0) 	main
				;;
			1)	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti si accorge che per installare un determinato"\
					"pacchetto sarebbe neccessario sovrascrivere un file già"\
					"presente nel sistema. Il nome del file in questione viene"\
					"stampato insieme al messaggio di errore."
				echo "Ci sono due possibili soluzioni:"
				echo "-> se vengono segnalati solo pochi file è possibile"\
					"rimuoverli manualmente tramite il comando 'sudo rm"\
					"/percorso/completo/file';"
				echo "-> se i file sono molto numerosi è possibile automatizzare"\
					"il processo dando al gestore di pacchetti il permesso di"\
					"sovrascrivere i file in conflitto, questa opziona va"\
					"utilizzata il meno possibile perché può avere effetti"\
					"collaterali anche gravi, per utilizzarla bisogna lanciare"\
					"il seguente comando di installazione fornendo il nome del"\
					"pacchetto che causa il problema 'sudo pacman -S --force"\
					"nomepacchetto'."
				;;
			2) 	echo ; echo
				echo "Questo messaggio di errore segnala l'impossibilità di"\
					"verificare correttamente la provenienza di un pacchetto."
				echo "Generalmente può essere risolto lanciando il seguenti"\
					"comandi:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				;;
			3) 	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti non riesce a scaricare dai repository online"\
					"i database o i pacchetti richiesti."
				echo "La prima cosa da verificare è la corretta connessione"\
					"ad una rete internet del sistema in uso."
				echo "Se il sistema risulta connesso ad internet ma il"\
					"problema persiste è probabile che il gestore di pacchetti"\
					"si stia rivolgendo ad un server non funzionante oppure"\
					"obsoleto, è quindi necessario generare una nuova lista dei"\
					"mirror; sui sistemi Manjaro Linux è possibile farlo"\
					"tramite 'pacman-mirrors'."
				echo "Il comando consigliato per generare velocemente una"\
					"nuova lista dei mirror è 'sudo pacman-mirrors -f10'."
				;;
			4) 	echo ; echo
				echo "Questo messaggio di errore segnala la presenza di un"\
					"file di lock, che indica un'operazione in corso da parte"\
					"del gestore di pacchetti, a volte questo file non viene"\
					"correttamente cancellato e rimane nonostante non ci sia"\
					"alcuna operazione in corso."
				echo "Dopo aver controllato che non ci sia alcun processo"\
					"di installazione/aggiornamento in atto (sia da parte di"\
					"pacman sia da parte dei gestori software da interfaccia"\
					"grafica) è possibile eliminare il file di lock lanciando"\
					"il comando 'sudo rm /var/lib/pacman/db.lck'."
				;;
			*)	echo ; echo
				echo "Non esiste l'opzione '$_SURE'."
		esac
	elif [[ $_LNG = eng ]]; then
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Which of this error the"\
			"package manager prints:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} error: failed to commit transaction"\
			"(conflicting files)"
		echo "${_BOLD}[2] ->${_NORMAL} error: failed to commit transaction"\
			"(invalid or corrupted package (PGP signature))"
		echo "${_BOLD}[3] ->${_NORMAL} error: failed retrieving file '...'"\
			"from ..."
		echo "${_BOLD}[4] ->${_NORMAL} error: failed to init transaction"\
			"(unable to lock database)"
		echo -e "\nIf the problem isn't listed here you could ask for help"\
			"online on your distribution's forum."
		echo "${_BOLD}[0] ->${_NORMAL} Return to main menu"
		echo -en "\n${_BOLD}Number: ${_NORMAL}"
		read -r -n1 _SURE
		case $_SURE in
			0) 	main
				;;
			1)	echo ; echo
				echo "This error message appears if a file is already present"\
					"in the filesystem when trying to install a new package, so"\
					"pacman decides not to overwrite it and prompt out an error."
					"The file name is printed in the error message."
				echo "There are two possible solutions:"
				echo "-> if there are only few conflicting files it's possible"\
					"to remove them with 'sudo rm /path/to/file';"
				echo "-> if there are many files it's possible to give pacman"
					"permission to overwrite the conflicting files, this option"\
					"can be dangerous and should be used only when necessary,"\
					"to use it you have to read from the error message the name"\
					"of the guilty package and execute 'sudo pacman -S --force"\
					"packagename'."
				;;
			2) 	echo ; echo
				echo "This error message appears if pacman fails to verify the"\
					"source of a package."
				echo "You should solve the problem with these commands:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				;;
			3) 	echo ; echo
				echo "This error message appears if pacman fails to download"\
					"needed packages or database from online repository."
				echo "First of all you should verify that your system is"\
					"connected to a network properly."
				echo "If the network conntection works, it's possible that"\
					"pacman is trying to download files from a non working or"\
					"obsolete server, therefore you should update your mirror"\
					"list; in a Manjaro Linux system you can use"\
					"'pacman-mirrors' to accomplish that."
				echo "To generate a new mirrorlist in few seconds the suggested"\
					"command is 'sudo pacman-mirrors -f10'."
				;;
			4) 	echo ; echo
				echo "This error message appears when pacman finds a lock file,"\
					"this means a package management transaction should be in"\
					"progress, sometimes this file remains also when there is"\
					"no such transaction."
				echo "You should verify there isn't any package management"\
					"process (from pacman or from any graphical package"\
					"management software), then you can remove the lock file"\
					"launching 'sudo rm /var/lib/pacman/db.lck'."
				;;
			*)	echo ; echo
				echo "There is no '$_SURE' option."

		esac
	fi

}

#
# Function containing english documentation text.
#
function doc_eng {
less -R << EOF
Press 'q' to quit documentation

${_BOLD}${_YELLOW}::Update system::${_NORMAL}

${_BOLD}Update packages from repositories (pacman -Syu)${_NORMAL}
Checks that local database is up to date with online repositories, compare packages version between database and installed packages, if versions are different runs update.
It prints a warning if some packages are newer than those in repositories, it's possible to downgrade these packages with 'pacman -Syuu'.

${_BOLD}Update packages from AUR (yaourt -Sua)${_NORMAL}
Updates packages from AUR repository, if needed. It can use different tools for that: 'pacaur' or 'yaourt'.

${_BOLD}${_YELLOW}::Packages cleaning::${_NORMAL}

${_BOLD}Search and uninstall orphaned packages (pacman -Qdtq)${_NORMAL}
Searches for packages installed as dependencies and no longer required, if there are any it asks before uninstalling them.

${_BOLD}Clean the cache of installed packages (paccache -rk2)${_NORMAL}
By default pacman keeps forever a backup of every version of every installed package, this backups can grow and fill the hard disk, so it must be cleaned from time to time. This command removes all backups for all installed packages keeping only two version, just in case it is necessary to perform a downgrade.

${_BOLD}Clean the cache of uninstalled packages (paccache -ruk0)${_NORMAL}
See previous command explanation. This works with unisnstalled packages and doesn't keep any backup version.

${_BOLD}Optimize (defragment) pacman database (pacman-optimize)${_NORMAL}
This command simply optimize access to pacman database, defragmenting it. For SSD it doesn't change anything in performances and it does a lot of writes, so it's not recommended.

${_BOLD}Configuration files check${_NORMAL}
Searches '*.pacnew' files in '/etc' directory, these are files created by 'pacman' when a package changes its configuration file, this way it doesn't overwrite valuable user's configurations; 'pacnew' files are useless (orphan) without the 'non pacnew' file (same filename without '.pacnew'), but sometimes they remain after package removal. If there is any useful '.pacnew' file you should consult the difference with the command 'pacdiff', further information in 'pacdiff --help' or at https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave.

${_BOLD}${_YELLOW}::Files cleaning::${_NORMAL}

${_BOLD}Log files cleaning${_NORMAL}
Cleans log file if the total size is over 200MB or the age is over 1 week, using the command 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. It runs only on systems with systemd as init.
Log files contain informations about most important events that happens in an operating system while it is alive, they are useful to find out the cause of errors or malfunctions.

${_BOLD}Clean old cache and thumbnail files${_NORMAL}
Searches in '~/.cache' and '~/.thumbnails' for files with last access more than 30 days ago and delete them, delete also empty folders inside those directories. Cache and thumbnail files are not necessary and are used by user applications to load faster images thumbnails or information.

${_BOLD}Search and clean residual files${_NORMAL}
Searches for files with names matching 'Thumbs.db', 'Desktop.ini', '.*.swp' and '*~'. This files are temporary files from Windows (first and second one) and from Linux (last two) application, that store them to save some information during work; they're important when you're using some applications, but they should disappears few seconds later, sometimes they don't. You should save your document in every application in use before using this option.

${_BOLD}Clean trash files (rm -rfv ~/.local/share/Trash/*)${_NORMAL}
Simply cleans the user trash, files are located in '~/.local/share/Trash/files'; prints all file names so the user at first glance can check deleted files and their number.

Press 'q' to quit documentation
EOF
}

#
# Function containing italian documentation text.
#
function doc_ita {
less -R << EOF
Premere 'q' per uscire dalla documentazione

${_BOLD}${_YELLOW}::Aggiornamento del sistema::${_NORMAL}

${_BOLD}Aggiornamento dei pacchetti dai repository ufficiali (pacman -Syu)${_NORMAL}
Controlla che il database locale sia aggiornato, se ci sono differenze tra le versioni dei pacchetti installati e di quelli presenti nel database effettua l'upgrade (innalzamento di versione). Il comando notifica se la versione installata di un pacchetto è più recente di quella nei repository, in questo caso può essere utile eseguire un downgrade (abbassamento di versione) tramite il comando 'pacman -Syuu'.

${_BOLD}Aggiornamento dei pacchetti di AUR (pacaur -Sua || yaourt -Sua)${_NORMAL}
Effettua l'aggiornamento dei pacchetti provenienti dai repository AUR, se necessario. Può utilizzare come strumenti (in ordine di priorità) 'pacaur' oppure 'yaourt'.

${_BOLD}${_YELLOW}::Pulizia pacchetti::${_NORMAL}

${_BOLD}Ricerca e rimozione dei pacchetti orfani (pacman -Qdtq)${_NORMAL}
Effettua una ricerca dei pacchetti orfani, cioè quelli installati come dipendenza di un altro pacchetto attualmente non più installato sul sistema, o le cui dipendenze sono state modificate.

${_BOLD}Pulizia della cache dei pacchetti installati (paccache -rk2)${_NORMAL}
Elimina le vecchie versioni dei pacchetti installati che pacman tiene come backup, lasciando le ultime due versioni. Il gestore di pacchetti pacman come comportamento predefinito tiene tutte le vecchie versioni dei pacchetti installati (e non), questo utilissimo backup può occupare col tempo molta memoria. È quindi consigliabile ripulire saltuariamente la cache dei pacchetti, lasciando solo le ultime versioni dei pacchetti, che possono risultare utili in caso di necessità di downgrade (installazione della versione precedente di un pacchetto).

${_BOLD}Pulizia della cache dei pacchetti non installati (paccache -ruk0)${_NORMAL}
Come la voce precedente, ma per i pacchetti non più installati sul sistema. Non essendoci necessità di effettuare downgrade non conserva neanche una versione di backup.

${_BOLD}Ottimizzazione (deframmentazione) del database di pacman (pacman-optimize)${_NORMAL}
Ottimizza l'accesso al database di pacman, deframmentandolo. Non è un'ottimizzazione utile nel caso in cui si utilizzi un SSD a causa del funzionamento stesso dei dischi a stato solido, inoltre causa inutili scritture sul disco che nel caso degli SSD sarebbe meglio limitare se non necessarie.

${_BOLD}Verifica file di configurazione${_NORMAL}
Viene verificata la presenza di file '*.pacnew' nella cartella di sistema '/etc', questi file vengono creati da 'pacman' quando un pacchetto aggiorna il proprio file di configurazione, questo per evitare di sovrascrivere i preziosi file di configurazione modificati dall'utente; nel caso in cui il file 'pacnew' non abbia un corrispondente file di configurazione (ha lo stesso nome ma senza '.pacnew') allora viene considerato orfano e non ha nessuna utilità. Nel caso in cui siano presenti file 'pacnew' non orfani è consigliata la consultazione degli stessi tramite il comando 'pacdiff', maggiori informazioni tramite 'pacdiff --help' o nella pagina https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave_(Italiano).

${_BOLD}${_YELLOW}::Pulizia file::${_NORMAL}

${_BOLD}Pulizia file di log${_NORMAL}
Pulisce i file di log se la loro dimensione supera i 200MB o se sono più vecchi di 1 settimana tramite il comando 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. Esegue questa operazione solo se il systema di init è 'systemd'.
I file di log contengono un resoconto di tutti gli avvenimenti rilevanti che succedono durante il funzionamento del sistema operativo, sono molto utili per capire le cause di errori o malfunzionamenti.

${_BOLD}Pulizia cache e miniature non recenti${_NORMAL}
Ricerca nelle cartelle '~/.cache' e '~/.thumbnails' file con l'ultimo accesso risalente a più di 30 giorni prima e li cancella, elimina anche le eventuali cartelle vuote che si trovano all'interno. I file presenti in cache sono utilizzati dalle applicazioni per velocizzare alcune operazioni comuni (es. caricamento copertine album in un riproduttore multimediale), invece i thumbnails sono le miniature delle immagini che vengono utilizzate (es. dal gestore file) per caricare più velocemente le anteprime delle immagini presenti nel sistema.

${_BOLD}Ricerca e rimozione file residui${_NORMAL}
Effettua una ricerca sui file che si chiamano 'Thumbs.db', 'Desktop.ini', '.*.swp' e '*~'. I primi due sono file creati dai sistemi Windows ed inutili su di un sistema Linux, che possono comparire se si condividono alcune cartelle con il sistema operativo di casa Microsoft. Gli ultimi due tipi di file sono file temporanei creati da molte applicazioni come salvataggio temporaneo del lavoro in corso, utile nel caso in cui improvvisamente il sistema si spenga per esempio; può succedere che questi file rimangano nel sistema più a lungo del necessario, creando disordine ed occupando spazio. Si consiglia di salvare i propri documenti in tutte le applicazioni aperte prima di eseguire questa opzione.

${_BOLD}Pulizia cestino (rm -rf ~/.local/share/Trash/*)${_NORMAL}
Cancella tutti i file presenti nel cestino dell'utente, i cui file sono contenuti in '~/.local/share/Trash/files', stampando tutti il nome dei file di modo che l'utente possa verificare velocemente l'entità dell'operazione.

Premere 'q' per uscire dalla documentazione
EOF
}

#
# This function prints the menu and handles choice of different options.
#
function main {
	while true; do
	clear
	unset _SURE
	echo
	echo "      _                                  _       _        "
	echo "  ___| | ___  __ _ _ __  _   _ _ __   __| | __ _| |_ ___  "
	echo " / __| |/ _ \/ _\` | '_ \| | | | '_ \ / _\` |/ _\` | __/ _ \ "
	echo "| (__| |  __/ (_| | | | | |_| | |_) | (_| | (_| | ||  __/ "
	echo " \___|_|\___|\__,_|_| |_|\__,_| .__/ \__,_|\__,_|\__\___| "
	echo "                              |_|                         "
	echo
	if [[ $_LNG = ita ]]; then
		echo " ┌────────────────────────────────────────┐"
		echo " │    1.  Aggiorna e pulisci tutto        │"
		echo " │    2.  Aggiorna il sistema             │"
		echo " │    3.  Pulisci i pacchetti             │"
		echo " │    4.  Pulisci i file                  │"
		echo " │                                        │"
		echo " │    7.  Risoluzione problemi frequenti  │"
		echo " │    8.  Documentazione                  │"
		echo " │    9.  Cambia lingua (eng|${_BOLD}ita${_NORMAL})         │"
		echo " │  q|0.  ESCI                            │"
		echo " └────────────────────────────────────────┘"
		echo
		echo -n " Seleziona un'opzione : "
	else
		echo " ┌────────────────────────────────────────┐"
		echo " │    1.  Update and clean everything     │"
		echo " │    2.  Update system                   │"
		echo " │    3.  Clean packages                  │"
		echo " │    4.  Clean files                     │"
		echo " │                                        │"
		echo " │    7.  Solve commmon errors            │"
		echo " │    8.  Documentation                   │"
		echo " │    9.  Change language (${_BOLD}eng${_NORMAL}|ita)       │"
		echo " │  q|0.  QUIT                            │"
		echo " └────────────────────────────────────────┘"
		echo
		echo -n " Select an option : "
	fi
	read -rs -n1 _SURE
	case $_SURE in
		1)
			clear
			sys_update
			echo
			clean_pkg
			echo
			clean_file
			echo
			[[ $_LNG = ita ]] && echo "Finito! Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo "Finished! Press any key to continue. "
			read -rs -n1
			;;
		2)
			clear
			sys_update
			echo
			[[ $_LNG = ita ]] && echo "Finito! Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo "Finished! Press any key to continue. "
			read -rs -n1
			;;
		3)
			clear
			clean_pkg
			echo
			[[ $_LNG = ita ]] && echo "Finito! Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo "Finished! Press any key to continue. "
			read -rs -n1
			;;
		4)
			clear
			clean_file
			echo
			[[ $_LNG = ita ]] && echo "Finito! Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo "Finished! Press any key to continue. "
			read -rs -n1
			;;
		7)
			clear
			trouble_shoot
			echo
			[[ $_LNG = ita ]] && echo "Finito! Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo "Finished! Press any key to continue. "
			read -rs -n1
			;;
		8)
			clear
			[[ $_LNG = ita ]] && doc_ita
			[[ $_LNG = eng ]] && doc_eng
			;;
		9)
			[[ $_LNG = eng ]] && _LNG="ita" || _LNG="eng"
			;;
		q|0)
			clear && exit 0
			;;
		*)
			echo
			echo
			[[ $_LNG = ita ]] && echo -n " Non esiste l'opzione '$_SURE'. Premi un tasto qualsiasi per continuare. "
			[[ $_LNG = eng ]] && echo -n " There is no '$_SURE' option. Press any key to continue. "
			read -rs -n1
			;;
	esac
	done
}

# Here begin the "main script"

if [[ $# -gt 0 ]] ; then
	[[ $_LNG = ita ]] && echo "Errore! Sono stati forniti i seguenti argomenti:"
	[[ $_LNG = eng ]] && echo "Error! Some arguments have been provided:"
	echo -en "\t" ; for i in "$@" ; do echo -n "$i" ; echo -n " " ; done ; echo ; echo
	[[ $_LNG = ita ]] && echo "Cleanupdate non ha bisogno di alcun argomento."
	[[ $_LNG = eng ]] && echo "Cleanupdate doesn't need any argument."
	exit 1
fi

main

exit 1
