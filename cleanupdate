#!/bin/bash
#
# 'cleanupdate' by cubanpit at github.com
#
# Initial script found somewhere on internet (thanks to unknown).
# Menu taken from a script by Chrysostomus.
#
# This script should help you to maintain an ArchLinux-based system.
# Report issue at github.com/cubanpit/cleanupdate
#
################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

# -e: Exit immediately if a command exits with a non-zero status.
# -u: Treat unset variables as an error when substituting.
set -eu

# Define some useful text style and color
_BOLD=$(/bin/tput bold)
_NORMAL=$(/bin/tput sgr0)
_RED=$(/bin/tput setaf 1)
_GREEN=$(/bin/tput setaf 2)
_YELLOW=$(/bin/tput setaf 3)
_AQUA=$(/bin/tput setaf 6)
readonly _BOLD _NORMAL _RED _GREEN _YELLOW _AQUA

# Default language is English, but Italian it's available
_LNG="eng"
if [[ "$LANG" =~ "it_IT" ]]; then
	_LNG="ita"
fi

# Check if $HOME is defined, otherwise many commands can't work
if [[ -z $HOME ]]; then
	if [[ $_LNG = ita ]]; then
		echo "ERRORE: la variabile d'ambiente $HOME è vuota,"\
			"è impossibile ottenere il percordo per la home dell'utente." 1>&2
	else
		echo "ERROR: $HOME variable not set properly,"\
			"it is impossible to get the path of user's home." 1>&2
	fi
	exit 1
fi

#
# Function to convert file size in a format easier to read, it receives file
#  size in bytes.
# Usage: human_size "size in bytes"
#
function human_size {
	local num=$1
	if [[ $num -ge 1000000000 ]]; then
		num="$(( num / 1000000000 )) GB"
	elif [[ $num -ge 1000000 ]]; then
		num="$(( num / 1000000 )) MB"
	elif [[ $num -ge 1000 ]]; then
		num="$(( num / 1000 )) kB"
	elif [[ $num -ge 0 ]]; then
		num="$num B"
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: impossibile convertire numeri negativi." 1>&2
		else
			echo "ERROR: it's not possible to convert negative numbers." 1>&2
		fi
		exit 1
	fi
	echo "$num"
}

#
# Function to print a message after a transaction, communicating if it has been
#  executed, has been cenceled or has been skipped because unuseful.
# Usage: end_msg "ok|no|skip|warn" "message"
function end_msg {
	local mod=$1
	local msg=$2
	if [[ $mod = ok ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_GREEN}ESEGUITO${_NORMAL}"\
				"${_BOLD}] $msg ${_NORMAL}"
		else
			echo "${_BOLD}[${_GREEN}DONE${_NORMAL}${_BOLD}]"\
				"$msg ${_NORMAL}"
		fi
	elif [[ $mod = no ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_RED}ANNULLATO${_NORMAL}${_BOLD}]"\
				"$msg ${_NORMAL}"
		else
			echo "${_BOLD}[${_RED}CANCELED${_NORMAL}${_BOLD}]"\
				"$msg ${_NORMAL}"
		fi
	elif [[ $mod = skip ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_AQUA}SALTATO${_NORMAL}${_BOLD}]"\
				"$msg ${_NORMAL}"
		else
			echo "${_BOLD}[${_AQUA}SKIPPED${_NORMAL}${_BOLD}]"\
				"$msg ${_NORMAL}"
		fi
	elif [[ $mod = warn ]]; then
		if [[ $_LNG = ita ]]; then
			echo "${_BOLD}[${_YELLOW}ATTENZIONE${_NORMAL}"\
				"${_BOLD}] $msg ${_NORMAL}"
		else
			echo "${_BOLD}[${_YELLOW}WARNING${_NORMAL}"\
				"${_BOLD}] $msg ${_NORMAL}"
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: modalità sconosciuta, vedere funzione end_msg()." 1>&2
		else
			echo "ERROR: unknown option, see end_msg() function." 1>&2
		fi
		exit 1
	fi
}

#
# Function to print a question, setting the default answer.
# Usage: qst_msg "yes|no" "question"
#
function qst_msg {
	local mod=$1
	local msg=$2
	if [[ $mod = yes ]]; then
		if [[ $_LNG = ita ]]; then
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$msg [S/n]?${_NORMAL} "
		else
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$msg [Y/n]?${_NORMAL} "
		fi
	elif [[ $mod = no ]]; then
		if [[ $_LNG = ita ]]; then
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$msg [s/N]?${_NORMAL} "
		else
			echo -n "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD}"\
				"$msg [y/N]?${_NORMAL} "
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "ERRORE: risposta predefinita sconosciuta, vedere funzione"\
				"qst_msg()." 1>&2
		else
			echo "ERROR: unknown default answer, see qst_msg() function." 1>&2
		fi
		exit 1
	fi
}

#
# Function to check if the user is root.
# This script should not be executed as root.
#
function check_root {
	if [[ "$(id -u)" = "0" ]]
	then
		echo "This script should not be executed as root." 1>&2
		echo "Please retry running it as user." 1>&2
		exit 126
	fi
}

#
# Function to check arguments passed to the script.
# This script doesn't accept any argument.
#
function check_args {
	if [[ $# -gt 0 ]] ; then
		if [[ $_LNG = ita ]]; then
			echo "Errore! Sono stati forniti i seguenti argomenti:" 1>&2
		else
			echo "Error! Some arguments have been provided:" 1>&2
		fi
		echo -en "\t" 1>&2 ; for i in "$@" ; do echo -n "$i" 1>&2 ; \
			echo -n " " 1>&2 ; done ; echo 1>&2 ; echo 1>&2
		if [[ $_LNG = ita ]]; then
			echo "Cleanupdate non ha bisogno di alcuni argomento." 1>&2
		else
			echo "Cleanupdate doesn't need any argument." 1>&2
		fi
		exit 1
	fi
}

#
# This function checks if there is any orphan package and asks the user if he
#  wants to remove them.
#
function orph_pkgs {
	if [[ $orphcheck = false ]]; then
		# Look for orphan packages, they could be pkgs removed from repositories
		#  and moved to AUR, better not to upgrade them silently.
		echo
		if [[ $_LNG = ita ]]; then
			echo "Ricerca pacchetti orfani in corso..."
		else
			echo "Looking for orphan packages..."
		fi
		local -a orphans=""
		if /bin/pacman -Qdtq >/dev/null ; then
			readarray -t orphans < <( /bin/pacman -Qdtq )
		fi
		if [[ -n ${orphans[0]} ]]; then
			orphcheck=true
			if [[ $_LNG = ita ]]; then
				end_msg "warn" "Sono presenti pacchetti orfani, se non sono stati installati volontariamente ne è consigliata la rimozione."
			else
				end_msg "warn" "There are orphan packages, if you haven't installed them explicitly it's a good choice to remove them."
			fi
			for i in "${orphans[@]}"; do
				echo "$i"
			done | /bin/column -x
			if [[ $_LNG = ita ]]; then
				qst_msg "yes" "Sono presenti ${#orphans[@]} pacchetti orfani, desideri rimuoverli"
			else
				qst_msg "yes" "There are ${#orphans[@]} orphaned packages, do you want to remove them"
			fi
			read -r sure
			if [[ $sure != "n" && $sure != "N" ]]; then
				/bin/sudo /bin/pacman --color always --noconfirm -Rs "${orphans[@]}"
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Pacchetti orfani"
				else
					end_msg "ok" "Orphan packages"
				fi
			else
				if [[ $_LNG = ita ]]; then
					end_msg "no" "Pacchetti orfani"
				else
					end_msg "no" "Orphan packages"
				fi
			fi
			echo
		else
			if [[ $_LNG = ita ]]; then
				end_msg "skip" "Non sono presenti pacchetti orfani."
			else
				end_msg "skip" "There are no orphan packages."
			fi
			echo
		fi
	fi
}

#
# Function containing all system update operation.
# Database sync, package upgrade, AUR upgrade.
#
function sys_update {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Aggiornamento del sistema::${_NORMAL} "
	else
		echo " ${_BOLD}::System update::${_NORMAL} "
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri aggiornare i pacchetti ufficiali"
	else
		qst_msg "yes" "Do you want to upgrade official packages"
	fi
	read -r sure
	if [[ $sure != "n" && $sure != "N" ]]; then
		local distro=""
		if [[ -f /etc/lsb-release ]]; then
			if /bin/grep -iq manjaro /etc/lsb-release ; then
				distro="manjaro"
			fi
		fi
		if [[ "$distro" = manjaro &&\
			$( /bin/stat /etc/pacman.d/mirrorlist | /bin/grep 'Modify' | \
			/bin/cut -d' ' -f2 ) != $( /bin/date +%Y-%m-%d ) ]]; then
			/bin/sudo /bin/pacman-mirrors --sync -f10
		fi
		local -a updates=""
		if [[ -n $(/bin/checkupdates) ]]; then
			readarray -t updates < <( /bin/checkupdates )
		fi
		if [[ -n ${updates[0]} ]]; then
			for i in "${updates[@]}"; do
				echo "$i"
			done | /bin/column -x
			if [[ $_LNG = ita ]]; then
				qst_msg "yes" "Ci sono ${#updates[@]} aggiornamenti disponibili, desideri installarli"
			else
				qst_msg "yes" "There are ${#updates[@]} available updates, do you want to install them"
			fi
			read -r sure
			if [[ $sure != "n" && $sure != "N" ]]; then
				/bin/sudo /bin/pacman -Syu --color always --noconfirm
				if /bin/sudo /bin/pacman -Syu 2>&1 | /bin/grep -q "is newer than"; then
					echo
					if [[ $_LNG = ita ]]; then
						qst_msg "yes" "Sono presenti pacchetti con versione più recente di quelli presenti nei repository, desideri abbassarli di versione"
					else
						qst_msg "yes" "There are packages with newer version than those in repository, do you want to downgrade them"
					fi
					read -r sure
					if [[ $sure != "n" && $sure != "N" ]]; then
						/bin/sudo /bin/pacman -Syuu --color always --noconfirm
					fi
				fi
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Aggiornamento pacchetti ufficiali"
				else
					end_msg "ok" "Official packages upgrade"
				fi
			else
				if [[ $_LNG = ita ]]; then
					end_msg "no" "Aggiornamento pacchetti ufficiali"
				else
					end_msg "no" "Official packages upgrade"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Non sono disponibili nuovi aggiornamenti."
				end_msg "skip" "Aggiornamento pacchetti ufficiali"
			else
				echo "There isn't any available update."
				end_msg "skip" "Official packages upgrade"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Aggiornamento pacchetti ufficiali"
		else
			end_msg "no" "Official packages upgrade"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri aggiornare i pacchetti di AUR"
	else
		qst_msg "yes" "Do you want to upgrade AUR packages"
	fi
	read -r sure
	if [[ $sure != "n" && $sure != "N" ]]; then
		orph_pkgs
		# Check if pacaur or yaourt are installed
		if [[ -x /bin/pacaur ]]; then
			/bin/pacaur -Syua --color always
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Aggiornamento AUR"
			else
				end_msg "ok" "AUR upgrade"
			fi
		elif [[ -x /bin/yaourt ]]; then
			/bin/yaourt -Sua --color
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Aggiornamento AUR"
			else
				end_msg "ok" "AUR upgrade"
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Non risulta installato né 'yaourt' né 'pacaur', non è"\
					"possibile accedere agli aggiornamenti AUR tramite questo script."
				end_msg "skip" "Aggiornamento AUR"
			else
				echo "You don't have neither 'yaourt' nor 'pacaur' installed,"\
					"you can't access AUR updates through this script."
				end_msg "skip" "AUR upgrade"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Aggiornamento AUR"
		else
			end_msg "no" "AUR upgrade"
		fi
	fi
}

#
# Function containing all package cleaning operation.
# Orphaned packages cleaning, cache cleaning, database optimization.
#
function clean_pkg {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Pulizia pacchetti::${_NORMAL} "
	else
		echo " ${_BOLD}::Packages cleaning::${_NORMAL} "
	fi
	orph_pkgs

	if [[ $_LNG = ita ]]; then
		echo "Controllo cache dei pacchetti installati in corso..."
	else
		echo "Checking installed package cache..."
	fi
	if /bin/paccache -dk2 | /bin/grep -q "no candidate packages found for pruning"; then
		if [[ $_LNG = ita ]]; then
			echo "Pulizia cache non necessaria."
			end_msg "skip" "Pulizia cache pacchetti installati"
		else
			echo "Cache cleaning not required."
			end_msg "skip" "Installed packages cache cleaning"
		fi
	else
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri pulire la cache dei pacchetti installati (conservando le ultime 2 versioni)"
		else
			qst_msg "yes" "Do you want to clean the cache of installed packages (keeping 2 versions)"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			/bin/sudo /bin/paccache -rk2 --nocolor
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Pulizia cache pacchetti installati"
			else
				end_msg "ok" "Installed packages cache cleaning"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pulizia cache pacchetti installati"
			else
				end_msg "no" "Installed packages cache cleaning"
			fi
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		echo "Controllo cache dei pacchetti disinstallati in corso..."
	else
		echo "Checking uninstalled package cache..."
	fi
	if /bin/paccache -duk0 | /bin/grep -q "no candidate packages found for pruning"; then
		if [[ $_LNG = ita ]]; then
			echo "Pulizia cache non necessaria."
			end_msg "skip" "Pulizia cache pacchetti disinstallati"
		else
			echo "Cache cleaning not required."
			end_msg "skip" "Uninstalled packages cache cleaning"
		fi
	else
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri pulire completamente la cache dei pacchetti disinstallati"
		else
			qst_msg "yes" "Do you want to completely clean the cache of uninstalled packages"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			/bin/sudo /bin/paccache -ruk0 --nocolor
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Pulizia cache pacchetti disinstallati"
			else
				end_msg "ok" "Uninstalled packages cache cleaning"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pulizia cache pacchetti disinstallati"
			else
				end_msg "no" "Uninstalled packages cache cleaning"
			fi
		fi
	fi
	echo
	# This part of the script try to check if the disk containing
	#  pacman database is a solid state drive.
	local rotat=false
	if [[ -d /var/lib/pacman ]]; then
		# Find disk on which database is located
		local disk
		disk=$(/bin/df -P /var/lib/pacman | /bin/tail -n 1 | \
			/bin/cut -d' ' -f 1 | /bin/sed -E 's/(\/dev\/|[0-9])//g')
		# Discover if database disk exist as device and is rotational
		[[ -n $disk && -b "/dev/$disk" && \
			-e "/sys/block/$disk/queue/rotational" && \
			$(/bin/cat "/sys/block/$disk/queue/rotational") -eq 1 ]] \
			&& rotat=true
	else
		if [[ $_LNG = ita ]]; then
			end_msg "warn" "Il database di pacman non è stato trovato al percorso predefinito, se non è stato spostato manualmente sussiste un problema."
		else
			end_msg "warn" "It is impossible to find pacman database at default path, if you have not changed it manually there is a problem in this system."
		fi
	fi
	if [[ "$rotat" = true ]]; then
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri ottimizzare (deframmentare) il database di pacman"
		else
			qst_msg "yes" "Do you want to optimize (defragment) pacman database"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			/bin/sudo /bin/pacman-optimize --nocolor
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Ottimizzazione database"
			else
				end_msg "ok" "Database optimization"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Ottimizzazione database"
			else
				end_msg "no" "Database optimization"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "Il database di pacman non risiede su un disco"\
				"rotazionale, non è necessario eseguire la deframmentazione."
			end_msg "skip" "Ottimizzazione database"
		else
			echo "The pacman database lives on a non"\
				"rotational disk, defragmentation is not needed."
			end_msg "skip" "Database optimization"
		fi
	fi
	# Here we'll check for '.pacnew' files, then catch '.pacnew' files that are
	#  useless (there is 'foo.conf.pacnew' and not 'foo.conf'), finally warn the
	#  user about it.
	local i=0
	local -a pacnews=""
	while IFS= read -r -d '' file; do
		pacnews[i++]="$file"
	done < <(/bin/find /etc -name "*.pacnew" -print0 2>/dev/null)
	local -a orphan_pacnews=""
	if [[ -n ${pacnews[0]} ]]; then
		local -i j=0
		for i in "${pacnews[@]}"; do
			local pacold=${i//\.pacnew/}
			if [[ ! -f "$pacold" ]]; then
				orphan_pacnews[j++]="$pacold.pacnew"
			fi
		done
	fi
	if [[ -n ${orphan_pacnews[0]} ]]; then
		echo
		for i in "${orphan_pacnews[@]}"; do
			echo "$i"
		done
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Sono presenti questi ${#orphan_pacnews[@]} file '.pacnew' orfani (consultare la documentazione [8] per maggiori informazioni), vuoi eliminarli"
		else
			qst_msg "yes" "These are ${#orphan_pacnews[@]} orphan '.pacnew' files (read documentation [8] for further information), do you want to erase them"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			for i in "${orphan_pacnews[@]}"; do
				/bin/sudo /bin/rm -f "$i"
			done
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "File di configurazione orfani"
			else
				end_msg "ok" "Orphan configuration files"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "File di configurazione orfani"
			else
				end_msg "no" "Orphan configuration files"
			fi
		fi
	fi
	if [[ -n ${pacnews[0]} && ( ${#pacnews[@]} -gt ${#orphan_pacnews[@]} || -z ${orphan_pacnews[0]} ) ]]; then
		echo
		if [[ $_LNG = ita ]]; then
			end_msg "warn" "Sono presenti nuove versioni di alcuni file di configurazione. Valutare le modifiche tramite il comando 'pacdiff'. Consultare la documentazione [8] per maggiori informazioni."
		else
			end_msg "warn" "There are updated version of some configuration files. Assess the changes with the command 'pacdiff'. Read documentation [8] for further information."
		fi
	fi
}

#
# Function containing all file cleaning operation.
# Cache & thumbs cleaning, residual file cleaning, trash cleaning.
#
function clean_file {
	if [[ $_LNG = ita ]]; then
		echo " ${_BOLD}::Pulizia file::${_NORMAL} "
	else
		echo " ${_BOLD}::Files cleaning::${_NORMAL} "
	fi
	if [[ "$(/bin/cat /proc/1/comm)" = systemd ]]; then
		echo
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "Desideri ripulire i file di log per guadagnare spazio su disco"
		else
			qst_msg "yes" "Do you want to clean log files to save disk space"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			/bin/sudo /bin/journalctl --vacuum-size=200M --vacuum-time=2weeks | /bin/tail -n 1
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Pulizia file di log"
			else
				end_msg "ok" "Log files cleaning"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pulizia file di log"
			else
				end_msg "no" "Log files cleaning"
			fi
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		echo "Stima dello spazio occupato da cache e miniature poco recenti in"\
			"corso..."
	else
		echo "Calculating disk space taken by old cache and thumbnails..."
	fi
	# This part checks the existence of thumbnails and cache folders, then
	#  calculate the total space they take.
	local oldsize=0
	if [[ -d "$HOME/.thumbnails" ]]; then
		oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.thumbnails" -type f\
			-atime +30 -print0 | /bin/du --files0-from=- -cb |\
			/bin/tail -1 | /bin/cut -f 1 )" | bc)
		oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.thumbnails" -empty -type d\
			-atime +30 -print0 | /bin/du --files0-from=- -cb |\
			/bin/tail -1 | /bin/cut -f 1 )" | bc)
	fi
	if [[ -d "$HOME/.thumbnails" ]]; then
		oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.cache" -name pacaur\
			-prune -o \( -type f -atime +30 -print0 \) | /bin/du\
			--files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
		oldsize=$(echo "$oldsize+$( /bin/find "$HOME/.cache" -name pacaur\
			-prune -o \( -empty -type d -atime +30 -print0 \) | /bin/du\
			--files0-from=- -cb | /bin/tail -1 | /bin/cut -f 1 )" | bc)
	fi
	if [[ $oldsize -gt 0 ]]; then
		oldsize=$(human_size "$oldsize")
		if [[ $_LNG = ita ]]; then
			qst_msg "yes" "L'eliminazione di questi file libererà $oldsize di spazio su disco, vuoi procedere"
		else
			qst_msg "yes" "The deletion of these files frees $oldsize of disk space, do you want to continue"
		fi
		read -r sure
		if [[ $sure != "n" && $sure != "N" ]]; then
			if [[ -d "$HOME/.thumbnails" ]]; then
				/bin/find "$HOME/.thumbnails" -type f -atime +30 -print0 |\
					xargs -0 /bin/rm -f
				/bin/find "$HOME/.thumbnails" -empty -type d -atime +30\
					-print0 | xargs -0 /bin/rm -rf
			fi
			if [[ -d "$HOME/.cache" ]]; then
				/bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
					\( -type f -atime +30 -print0 \) | xargs -0 /bin/rm -f
				/bin/find "$HOME/.cache" -name 'pacaur' -prune -o\
					\( -empty -type d -atime +30 -print0 \) | xargs -0\
					/bin/rm -rf
			fi
			if [[ $_LNG = ita ]]; then
				end_msg "ok" "Pulizia cache e miniature"
			else
				end_msg "ok" "Thumbs and cache cleaning"
			fi
		else
			if [[ $_LNG = ita ]]; then
				end_msg "no" "Pulizia cache e miniature"
			else
				end_msg "no" "Thumbs and cache cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			echo "Non c'è necessità di eliminare alcun"\
				"file, le cartelle sono sufficientemente pulite."
			end_msg "skip" "Pulizia cache e miniature"
		else
			echo "There is no need to delete any file,"\
				"these folders are pretty clean."
			end_msg "skip" "Thumbs and cache cleaning"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri cercare file residui"
	else
		qst_msg "yes" "Do you want to search for residual files"
	fi
	read -r sure
	if [[ $sure != "n" && $sure != "N" ]]; then
		# Null separated output will be used just to have less problem with
		#  strange characters.
		local i=0
		local -a residfiles=""
		while IFS= read -r -d '' file; do
			residfiles[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "*~" -user "$USER" -print0\
			2>/dev/null)
		while IFS= read -r -d '' file; do
			residfiles[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name ".*.swp" -user "$USER" -print0\
			2>/dev/null)
		while IFS= read -r -d '' file; do
			residfiles[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "Desktop.ini" -user "$USER"\
			-print0 2>/dev/null)
		while IFS= read -r -d '' file; do
			residfiles[i++]="$file"
		done < <(/bin/find "$HOME" -name "*Steam*" -prune -o -path\
			"$HOME/.cache" -prune -o -path "$HOME/.thumbnails" -prune -o\
			-path "$HOME/.mozilla" -prune -o -path "$HOME/.thunderbird" -prune\
			-o -path "*/.git" -prune -o -name "Thumbs.db" -user "$USER" -print0\
			2>/dev/null)
		if [[ -n ${residfiles[0]} ]]; then
			# Print every residual file
			for i in "${residfiles[@]}"; do
				echo "$i"
			done | /bin/column -x
			# Calculate space taken by residual files
			local residsize=0
			for i in "${residfiles[@]}"; do
				residsize=$( echo "$residsize+$( /bin/du -b "$i" | /bin/cut -f 1 )" | bc )
			done
			residsize=$(human_size "$residsize")
			if [[ $_LNG = ita ]]; then
				qst_msg "no" "Ci sono ${#residfiles[@]} file residui che occupano $residsize di spazio su disco, desideri rimuoverli"
			else
				qst_msg "no" "There are ${#residfiles[@]} residual files that take $residsize of disk space, do you want to remove them"
			fi
			read -r sure
			if [[ ( $_LNG != ita && ( $sure = y || $sure = Y )) || ( $_LNG = ita && ( $sure = s || $sure = S ) ) ]]; then
				# Remove every residual file
				for i in "${residfiles[@]}"; do
					/bin/rm -f "$i"
				done
				if [[ $_LNG = ita ]]; then
					end_msg "ok" "Pulizia file residui"
				else
					end_msg "ok" "Residual files cleaning"
				fi
			else
				if [[ $_LNG = ita ]]; then
					end_msg "no" "Pulizia file residui"
				else
					end_msg "no" "Residual files cleaning"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Non sono presenti file residui."
				end_msg "skip" "Pulizia file residui"
			else
				echo "There are no residual files."
				end_msg "skip" "Residual files cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia file residui"
		else
			end_msg "no" "Residual files search"
		fi
	fi
	echo
	if [[ $_LNG = ita ]]; then
		qst_msg "yes" "Desideri controllare lo stato del cestino"
	else
		qst_msg "yes" "Do you want to check trash status"
	fi
	read -r sure
	if [[ $sure != "n" && $sure != "N" ]]; then
		if [[ -d "$HOME/.local/share/Trash/files" ]]; then
			local i=0
			local -a trashfiles=""
			while IFS= read -r -d '' file; do
				trashfiles[i++]="$file"
			done < <(/bin/find "$HOME/.local/share/Trash/files" -mindepth 1 -maxdepth 1 -print0 2>/dev/null)
			# This for loop counts total space taken by files and prints every
			#  file name next to the file size.
			local trashsize=0
			if [[ -n ${trashfiles[0]} ]]; then
				for i in "${trashfiles[@]}"; do
					local filename
					filename=$( basename "$i" )
					local filesize
					filesize=$( /bin/du -bs "$i" | /bin/cut -f 1 )
					trashsize=$( echo "$trashsize+$filesize" | bc )
					filesize=$( human_size "$filesize" )
					echo -ne "   $filesize   \t"
					if [[ -d "$i" ]]; then
						filename+="/"
						echo "${_BOLD}$filename${_NORMAL}"
					else
						echo "$filename"
					fi
				done
				trashsize=$(human_size "$trashsize")
				if [[ $_LNG = ita ]]; then
					qst_msg "no" "Sono presenti ${#trashfiles[@]} elementi che occupano $trashsize di spazio sul disco, desideri eliminarli definitivamente"
				else
					qst_msg "no" "There are ${#trashfiles[@]} items that take $trashsize of disk space, do you want do definetely delete them"
				fi
				read -r sure
				if [[ ( $_LNG != ita && ( $sure = y || $sure = Y ) ) || ( $_LNG = ita && ( $sure = s || $sure = S ) ) ]]; then
					/bin/rm -rf "$HOME/.local/share/Trash/files"
					/bin/rm -rf "$HOME/.local/share/Trash/info"
					if [[ $_LNG = ita ]]; then
						end_msg "ok" "Pulizia cestino"
					else
						end_msg "ok" "Trash cleaning"
					fi
				else
					if [[ $_LNG = ita ]]; then
						end_msg "no" "Pulizia cestino"
					else
						end_msg "no" "Trash cleaning"
					fi
				fi
			else
				if [[ $_LNG = ita ]]; then
					echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
					end_msg "skip" "Pulizia cestino"
				else
					echo "Trash is completely empty, there is no need to clean it."
					end_msg "skip" "Trash cleaning"
				fi
			fi
		else
			if [[ $_LNG = ita ]]; then
				echo "Il cestino è completamente vuoto, non c'è alcun bisogno di svuotarlo."
				end_msg "skip" "Pulizia cestino"
			else
				echo "Trash is completely empty, there is no need to clean it."
				end_msg "skip" "Trash cleaning"
			fi
		fi
	else
		if [[ $_LNG = ita ]]; then
			end_msg "no" "Pulizia cestino"
		else
			end_msg "no" "Trash cleaning"
		fi
	fi
}

#
# Function containing pacman troubleshooting
#
function trouble_shoot {
	local again=true
while [[ $again = true ]]; do
	clear
	if [[ $_LNG = ita ]]; then
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Indicare quale di questi"\
			"messaggi restituisce il gestore di pacchetti:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (file in conflitto)"
		echo "${_BOLD}[2] ->${_NORMAL} errore: impossibile eseguire"\
			"l'operazione richiesta (il pacchetto non è valido oppure è"\
			"corrotto (firma PGP))"
		echo "${_BOLD}[3] ->${_NORMAL} errore: impossibile scaricare il"\
			"pacchetto '...' da ..."
		echo "${_BOLD}[4] ->${_NORMAL} errore: impossibile bloccare il"\
			"database: File già esistente"
		echo -e "\nSe il problema non è qui elencato si consiglia di chiedere"\
			"aiuto sul forum online della propria distribuzione."
		echo "${_BOLD}[q|0] ->${_NORMAL} Torna al menù principale"
		echo -en "\n${_BOLD}Opzione: ${_NORMAL}"
		read -r -n1 sure
		case $sure in
			q|0) 	again=false
				;;
			1)	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti si accorge che per installare un determinato"\
					"pacchetto sarebbe neccessario sovrascrivere un file già"\
					"presente nel sistema. Il nome del file in questione viene"\
					"stampato insieme al messaggio di errore."
				echo "Ci sono due possibili soluzioni:"
				echo "-> se vengono segnalati solo pochi file è possibile"\
					"rimuoverli manualmente tramite il comando 'sudo rm"\
					"/percorso/completo/file';"
				echo "-> se i file sono molto numerosi è possibile"\
					"automatizzare il processo dando al gestore di pacchetti"\
					"il permesso di sovrascrivere i file in conflitto, questa"\
					"opzione va utilizzata il meno possibile perché può avere"\
					"effetti collaterali anche gravi, per utilizzarla bisogna"\
					"lanciare il seguente comando di installazione fornendo il"\
					"nome del pacchetto che causa il problema 'sudo pacman -S"\
					"--force nomepacchetto'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			2) 	echo ; echo
				echo "Questo messaggio di errore segnala l'impossibilità di"\
					"verificare correttamente la provenienza di un pacchetto."
				echo "Generalmente può essere risolto lanciando il seguenti"\
					"comandi:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			3) 	echo ; echo
				echo "Questo messaggio di errore compare quando il gestore"\
					"di pacchetti non riesce a scaricare dai repository online"\
					"i database o i pacchetti richiesti."
				echo "La prima cosa da verificare è la corretta connessione"\
					"ad una rete internet del sistema in uso."
				echo "Se il sistema risulta connesso ad internet ma il"\
					"problema persiste è probabile che il gestore di pacchetti"\
					"si stia rivolgendo ad un server non funzionante oppure"\
					"obsoleto, è quindi necessario generare una nuova lista"\
					"dei mirror; sui sistemi Manjaro Linux è possibile farlo"\
					"tramite 'pacman-mirrors'."
				echo "Il comando consigliato per generare velocemente una"\
					"nuova lista dei mirror è 'sudo pacman-mirrors -f10'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			4) 	echo ; echo
				echo "Questo messaggio di errore segnala la presenza di un"\
					"file di lock, che indica un'operazione in corso da parte"\
					"del gestore di pacchetti, a volte questo file non viene"\
					"correttamente cancellato e rimane nonostante non ci sia"\
					"alcuna operazione in corso."
				echo "Dopo aver controllato che non ci sia alcun processo"\
					"di installazione/aggiornamento in atto (sia da parte di"\
					"pacman sia da parte dei gestori software da interfaccia"\
					"grafica) è possibile eliminare il file di lock lanciando"\
					"il comando 'sudo rm /var/lib/pacman/db.lck'."
				echo
				echo -n "Premi un tasto qualsiasi per continuare. "
				read -rs -n1
				;;
			*)	echo ; echo
				echo -n "Non esiste l'opzione '$sure'. Premi un tasto"\
					"qualsiasi per continuare. "
				read -rs -n1
		esac
	else
		echo -e "${_BOLD}${_YELLOW}>>${_NORMAL}${_BOLD} Select the error"\
			"message printed by the package manager:\n${_NORMAL}"
		echo "${_BOLD}[1] ->${_NORMAL} error: failed to commit transaction"\
			"(conflicting files)"
		echo "${_BOLD}[2] ->${_NORMAL} error: failed to commit transaction"\
			"(invalid or corrupted package (PGP signature))"
		echo "${_BOLD}[3] ->${_NORMAL} error: failed retrieving file '...'"\
			"from ..."
		echo "${_BOLD}[4] ->${_NORMAL} error: failed to init transaction"\
			"(unable to lock database)"
		echo -e "\nIf the problem is not listed here ask to your"\
			"distribution's online forum for help."
		echo "${_BOLD}[q|0] ->${_NORMAL} Return to main menu"
		echo -en "\n${_BOLD}Option: ${_NORMAL}"
		read -r -n1 sure
		case $sure in
			q|0) 	again=false
				;;
			1)	echo ; echo
				echo "This error message appears when the pckage manager needs"\
					"to overwrite an existing file in order to install a"\
					"certain package."\
					"The file name is printed in the error message."
				echo "There are two possible solutions:"
				echo "-> if there are only a few conflicting files, they can"\
					"be removed manually with 'sudo rm /path/to/file';"
				echo "-> if there are many conflicting files it is possible to"\
					"give pacman permission to overwrite them; however this"\
					"option can be dangerous and should be used only when"\
					"necessary; to use it read from the error message the name"\
					"of the package in question and execute 'sudo pacman -S"\
					"--force packagename'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			2) 	echo ; echo
				echo "This error message appears if pacman fails to verify the"\
					"source of a package."
				echo "These commands should solve the problem:"
				echo "  sudo rm -r /etc/pacman.d/gnupg"
				echo "  sudo pacman -Sy gnupg archlinux-keyring manjaro-keyring"
				echo "  sudo pacman-key --init"
				echo "  sudo pacman-key --populate arch manjaro"
				echo "  sudo pacman-key --refresh-keys"
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			3) 	echo ; echo
				echo "This error message appears if pacman fails to download"\
					"needed packages or database from online repository."
				echo "Verify first that your system is properly connected to a"\
					"network."
				echo "If the problem persists, it is possible that pacman is"\
					"trying to download files from a non working or obsolete"\
					"server, in this case the mirror list should be updated;"\
					"in a Manjaro Linux system you can use 'pacman-mirrors' to"\
					"accomplish that."
				echo "To generate a new mirrorlist in few seconds the"\
					"suggested command is 'sudo pacman-mirrors -f10'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			4) 	echo ; echo
				echo "This error message appears when pacman finds a lock"\
					"file, which indicates that a package management"\
					"transaction is in progress; however sometimes such files"\
					"remain also after the transaction is finished."
				echo "After making sure that no package management process"\
					"(from pacman or from any graphical package management"\
					"software) is in progress, then the lock file can be"\
					"removed launching 'sudo rm /var/lib/pacman/db.lck'."
				echo
				echo -n "Press any key to continue. "
				read -rs -n1
				;;
			*)	echo ; echo
				echo -n "There is no '$sure' option. Press any key to"\
					"continue. "
				read -rs -n1
		esac
	fi
done
}

#
# Function containing english documentation text.
#
function doc_eng {
less -R << EOF
Press 'q' to quit documentation

${_BOLD}${_YELLOW}::Update system::${_NORMAL}

${_BOLD}Update packages from repositories (pacman -Syu)${_NORMAL}
Checks that local database is up to date with online repositories, compare packages version between database and installed packages, if versions are different runs update.
It prints a warning if some packages are newer than those in repositories, it's possible to downgrade these packages with 'pacman -Syuu'.

${_BOLD}Update packages from AUR (yaourt -Sua)${_NORMAL}
Updates packages from AUR repository, if needed. It can use different tools for that: 'pacaur' or 'yaourt'.

${_BOLD}${_YELLOW}::Packages cleaning::${_NORMAL}

${_BOLD}Search and uninstall orphaned packages (pacman -Qdtq)${_NORMAL}
Searches for packages installed as dependencies and no longer required, if there are any it asks before uninstalling them.

${_BOLD}Clean the cache of installed packages (paccache -rk2)${_NORMAL}
By default pacman keeps forever a backup of every version of every installed package, this backups can grow and fill the hard disk, so it must be cleaned from time to time. This command removes all backups for all installed packages keeping only two version, just in case it is necessary to perform a downgrade.

${_BOLD}Clean the cache of uninstalled packages (paccache -ruk0)${_NORMAL}
See previous command explanation. This works with unisnstalled packages and doesn't keep any backup version.

${_BOLD}Optimize (defragment) pacman database (pacman-optimize)${_NORMAL}
This command simply optimize access to pacman database, defragmenting it. For SSD it doesn't change anything in performances and it does a lot of writes, so it's not recommended.

${_BOLD}Configuration files check${_NORMAL}
Searches '*.pacnew' files in '/etc' directory, these are files created by 'pacman' when a package changes its configuration file, this way it doesn't overwrite valuable user's configurations; 'pacnew' files are useless (orphan) without the 'non pacnew' file (same filename without '.pacnew'), but sometimes they remain after package removal. If there is any useful '.pacnew' file you should consult the difference with the command 'pacdiff', further information in 'pacdiff --help' or at https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave.

${_BOLD}${_YELLOW}::Files cleaning::${_NORMAL}

${_BOLD}Log files cleaning${_NORMAL}
Cleans log file if the total size is over 200MB or the age is over 1 week, using the command 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. It runs only on systems with systemd as init.
Log files contain informations about most important events that happens in an operating system while it is alive, they are useful to find out the cause of errors or malfunctions.

${_BOLD}Clean old cache and thumbnail files${_NORMAL}
Searches in '$HOME/.cache' and '$HOME/.thumbnails' for files with last access more than 30 days ago and delete them, delete also empty folders inside those directories. Cache and thumbnail files are not necessary and are used by user applications to load faster images thumbnails or information.

${_BOLD}Search and clean residual files${_NORMAL}
Searches for files with names matching 'Thumbs.db', 'Desktop.ini', '.*.swp' and '*~'. This files are temporary files from Windows (first and second one) and from Linux (last two) application, that store them to save some information during work; they're important when you're using some applications, but they should disappears few seconds later, sometimes they don't. You should save your document in every application in use before using this option.

${_BOLD}Clean trash files (rm -rfv $HOME/.local/share/Trash/*)${_NORMAL}
Simply cleans the user trash, files are located in '$HOME/.local/share/Trash/files'; prints all file names so the user at first glance can check deleted files and their number.

Press 'q' to quit documentation
EOF
}

#
# Function containing italian documentation text.
#
function doc_ita {
less -R << EOF
Premere 'q' per uscire dalla documentazione

${_BOLD}${_YELLOW}::Aggiornamento del sistema::${_NORMAL}

${_BOLD}Aggiornamento dei pacchetti dai repository ufficiali (pacman -Syu)${_NORMAL}
Controlla che il database locale sia aggiornato, se ci sono differenze tra le versioni dei pacchetti installati e di quelli presenti nel database effettua l'upgrade (innalzamento di versione). Il comando notifica se la versione installata di un pacchetto è più recente di quella nei repository, in questo caso può essere utile eseguire un downgrade (abbassamento di versione) tramite il comando 'pacman -Syuu'.

${_BOLD}Aggiornamento dei pacchetti di AUR (pacaur -Sua else
yaourt -Sua)${_NORMAL}
Effettua l'aggiornamento dei pacchetti provenienti dai repository AUR, se necessario. Può utilizzare come strumenti (in ordine di priorità) 'pacaur' oppure 'yaourt'.

${_BOLD}${_YELLOW}::Pulizia pacchetti::${_NORMAL}

${_BOLD}Ricerca e rimozione dei pacchetti orfani (pacman -Qdtq)${_NORMAL}
Effettua una ricerca dei pacchetti orfani, cioè quelli installati come dipendenza di un altro pacchetto attualmente non più installato sul sistema, o le cui dipendenze sono state modificate.

${_BOLD}Pulizia della cache dei pacchetti installati (paccache -rk2)${_NORMAL}
Elimina le vecchie versioni dei pacchetti installati che pacman tiene come backup, lasciando le ultime due versioni. Il gestore di pacchetti pacman come comportamento predefinito tiene tutte le vecchie versioni dei pacchetti installati (e non), questo utilissimo backup può occupare col tempo molta memoria. È quindi consigliabile ripulire saltuariamente la cache dei pacchetti, lasciando solo le ultime versioni dei pacchetti, che possono risultare utili in caso di necessità di downgrade (installazione della versione precedente di un pacchetto).

${_BOLD}Pulizia della cache dei pacchetti non installati (paccache -ruk0)${_NORMAL}
Come la voce precedente, ma per i pacchetti non più installati sul sistema. Non essendoci necessità di effettuare downgrade non conserva neanche una versione di backup.

${_BOLD}Ottimizzazione (deframmentazione) del database di pacman (pacman-optimize)${_NORMAL}
Ottimizza l'accesso al database di pacman, deframmentandolo. Non è un'ottimizzazione utile nel caso in cui si utilizzi un SSD a causa del funzionamento stesso dei dischi a stato solido, inoltre causa inutili scritture sul disco che nel caso degli SSD sarebbe meglio limitare se non necessarie.

${_BOLD}Verifica file di configurazione${_NORMAL}
Viene verificata la presenza di file '*.pacnew' nella cartella di sistema '/etc', questi file vengono creati da 'pacman' quando un pacchetto aggiorna il proprio file di configurazione, questo per evitare di sovrascrivere i preziosi file di configurazione modificati dall'utente; nel caso in cui il file 'pacnew' non abbia un corrispondente file di configurazione (ha lo stesso nome ma senza '.pacnew') allora viene considerato orfano e non ha nessuna utilità. Nel caso in cui siano presenti file 'pacnew' non orfani è consigliata la consultazione degli stessi tramite il comando 'pacdiff', maggiori informazioni tramite 'pacdiff --help' o nella pagina https://wiki.archlinux.org/index.php/Pacman/Pacnew_and_Pacsave_(Italiano).

${_BOLD}${_YELLOW}::Pulizia file::${_NORMAL}

${_BOLD}Pulizia file di log${_NORMAL}
Pulisce i file di log se la loro dimensione supera i 200MB o se sono più vecchi di 1 settimana tramite il comando 'journalctl --vacuum-size=200M --vacuum-time=1weeks'. Esegue questa operazione solo se il systema di init è 'systemd'.
I file di log contengono un resoconto di tutti gli avvenimenti rilevanti che succedono durante il funzionamento del sistema operativo, sono molto utili per capire le cause di errori o malfunzionamenti.

${_BOLD}Pulizia cache e miniature non recenti${_NORMAL}
Ricerca nelle cartelle '$HOME/.cache' e '$HOME/.thumbnails' file con l'ultimo accesso risalente a più di 30 giorni prima e li cancella, elimina anche le eventuali cartelle vuote che si trovano all'interno. I file presenti in cache sono utilizzati dalle applicazioni per velocizzare alcune operazioni comuni (es. caricamento copertine album in un riproduttore multimediale), invece i thumbnails sono le miniature delle immagini che vengono utilizzate (es. dal gestore file) per caricare più velocemente le anteprime delle immagini presenti nel sistema.

${_BOLD}Ricerca e rimozione file residui${_NORMAL}
Effettua una ricerca sui file che si chiamano 'Thumbs.db', 'Desktop.ini', '.*.swp' e '*~'. I primi due sono file creati dai sistemi Windows ed inutili su di un sistema Linux, che possono comparire se si condividono alcune cartelle con il sistema operativo di casa Microsoft. Gli ultimi due tipi di file sono file temporanei creati da molte applicazioni come salvataggio temporaneo del lavoro in corso, utile nel caso in cui improvvisamente il sistema si spenga per esempio; può succedere che questi file rimangano nel sistema più a lungo del necessario, creando disordine ed occupando spazio. Si consiglia di salvare i propri documenti in tutte le applicazioni aperte prima di eseguire questa opzione.

${_BOLD}Pulizia cestino (rm -rf $HOME/.local/share/Trash/*)${_NORMAL}
Cancella tutti i file presenti nel cestino dell'utente, i cui file sono contenuti in '$HOME/.local/share/Trash/files', stampando tutti il nome dei file di modo che l'utente possa verificare velocemente l'entità dell'operazione.

Premere 'q' per uscire dalla documentazione
EOF
}

#
# This function prints the menu and handles choice of different options.
#
function main {
	local sure
	while true; do
		clear
		unset sure

		# This variable is used to perform only one time 'per cycle' the check
		#  for orphan packages, otherwise the check will occur before AUR update
		#  and inside 'Clean packages' function.
		local orphcheck=false

		echo
		echo "      _                                  _       _        "
		echo "  ___| | ___  __ _ _ __  _   _ _ __   __| | __ _| |_ ___  "
		echo " / __| |/ _ \/ _\` | '_ \| | | | '_ \ / _\` |/ _\` | __/ _ \ "
		echo "| (__| |  __/ (_| | | | | |_| | |_) | (_| | (_| | ||  __/ "
		echo " \___|_|\___|\__,_|_| |_|\__,_| .__/ \__,_|\__,_|\__\___| "
		echo "                              |_|                         "
		echo
		if [[ $_LNG = ita ]]; then
			echo " ┌────────────────────────────────────────┐"
			echo " │    1.  Aggiorna e pulisci tutto        │"
			echo " │    2.  Aggiorna il sistema             │"
			echo " │    3.  Pulisci i pacchetti             │"
			echo " │    4.  Pulisci i file                  │"
			echo " │                                        │"
			echo " │    7.  Risoluzione problemi frequenti  │"
			echo " │    8.  Documentazione                  │"
			echo " │    9.  Cambia lingua (eng|${_BOLD}ita${_NORMAL})         │"
			echo " │  q|0.  ESCI                            │"
			echo " └────────────────────────────────────────┘"
			echo
			echo -n " Seleziona un'opzione : "
		else
			echo " ┌────────────────────────────────────────┐"
			echo " │    1.  Update and clean everything     │"
			echo " │    2.  Update system                   │"
			echo " │    3.  Clean packages                  │"
			echo " │    4.  Clean files                     │"
			echo " │                                        │"
			echo " │    7.  Solve commmon errors            │"
			echo " │    8.  Documentation                   │"
			echo " │    9.  Change language (${_BOLD}eng${_NORMAL}|ita)       │"
			echo " │  q|0.  QUIT                            │"
			echo " └────────────────────────────────────────┘"
			echo
			echo -n " Select an option : "
		fi
		read -rs -n1 sure
		case $sure in
			1)
				clear
				sys_update
				echo
				clean_pkg
				echo
				clean_file
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			2)
				clear
				sys_update
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			3)
				clear
				clean_pkg
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			4)
				clear
				clean_file
				echo
				if [[ $_LNG = ita ]]; then
					echo -n "Finito! Premi un tasto qualsiasi per continuare. "
				else
					echo -n "Finished! Press any key to continue. "
				fi
				read -rs -n1
				;;
			7)
				clear
				trouble_shoot
				;;
			8)
				clear
				if [[ $_LNG = ita ]]; then
					doc_ita
				else
					doc_eng
				fi
				;;
			9)
				if [[ $_LNG = ita ]]; then
					_LNG="eng"
				else
					_LNG="ita"
				fi
				;;
			q|0)
				# Clear terminal, scrollback included
				clear && echo -en "\e[3J"
				exit 0
				;;
			*)
				echo
				echo
				if [[ $_LNG = ita ]]; then
					echo -n " Non esiste l'opzione '$sure'. Premi un tasto"\
						"qualsiasi per continuare. "
				else
					echo -n " There is no '$sure' option. Press any key to"\
						"continue. "
				fi
				read -rs -n1
		esac
	done
}

# Here begins the "main script"

# Enable debug
#set -x

check_root
check_args "$@"

# Launch the long search for residual file and put everything in background,
#  this way the second execution will be faster on hard disk, because everything
#  is already in cache.
/bin/find "$HOME" -name "*Steam*" -prune -o -path "$HOME/.cache" -prune -o\
	-path "$HOME/.thumbnails" -prune -o -path "$HOME/.mozilla" -prune -o\
	-path "$HOME/.thunderbird" -prune -o -path "*/.git" -prune -o\
	-print >/dev/null 2>&1 &

main

# Disable debug
#set +x

exit 1
